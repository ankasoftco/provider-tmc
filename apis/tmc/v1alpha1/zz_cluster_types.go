/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AdvancedConfigsObservation struct {

	// The key of the advanced configuration parameters
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// The value of the advanced configuration parameters
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type AdvancedConfigsParameters struct {

	// The key of the advanced configuration parameters
	// +kubebuilder:validation:Required
	Key *string `json:"key" tf:"key,omitempty"`

	// The value of the advanced configuration parameters
	// +kubebuilder:validation:Required
	Value *string `json:"value" tf:"value,omitempty"`
}

type AttachK8SClusterObservation struct {

	// Attach cluster description
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Attach cluster KUBECONFIG path
	KubeconfigFile *string `json:"kubeconfigFile,omitempty" tf:"kubeconfig_file,omitempty"`
}

type AttachK8SClusterParameters struct {

	// Attach cluster description
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Attach cluster KUBECONFIG path
	// +kubebuilder:validation:Optional
	KubeconfigFile *string `json:"kubeconfigFile,omitempty" tf:"kubeconfig_file,omitempty"`

	// Attach cluster KUBECONFIG
	// +kubebuilder:validation:Optional
	KubeconfigRawSecretRef *v1.SecretKeySelector `json:"kubeconfigRawSecretRef,omitempty" tf:"-"`
}

type ClusterMetaObservation struct {

	// Annotations for the resource
	Annotations map[string]*string `json:"annotations,omitempty" tf:"annotations,omitempty"`

	// Description of the resource
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Labels for the resource
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// Resource version of the resource
	ResourceVersion *string `json:"resourceVersion,omitempty" tf:"resource_version,omitempty"`

	// UID of the resource
	UID *string `json:"uid,omitempty" tf:"uid,omitempty"`
}

type ClusterMetaParameters struct {

	// Annotations for the resource
	// +kubebuilder:validation:Optional
	Annotations map[string]*string `json:"annotations,omitempty" tf:"annotations,omitempty"`

	// Description of the resource
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Labels for the resource
	// +kubebuilder:validation:Optional
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`
}

type ClusterObservation struct {
	AttachK8SCluster []AttachK8SClusterObservation `json:"attachK8SCluster,omitempty" tf:"attach_k8s_cluster,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// Name of the management cluster
	ManagementClusterName *string `json:"managementClusterName,omitempty" tf:"management_cluster_name,omitempty"`

	// Metadata for the resource
	Meta []ClusterMetaObservation `json:"meta,omitempty" tf:"meta,omitempty"`

	// Name of this cluster
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Provisioner of the cluster
	ProvisionerName *string `json:"provisionerName,omitempty" tf:"provisioner_name,omitempty"`

	// Wait timeout duration until cluster resource reaches READY state. Accepted timeout duration values like 5s, 45m, or 3h, higher than zero. Should be set to 0 in case of simple attach cluster where kubeconfig input is not provided.
	ReadyWaitTimeout *string `json:"readyWaitTimeout,omitempty" tf:"ready_wait_timeout,omitempty"`

	// Spec for the cluster
	Spec []ClusterSpecObservation `json:"spec,omitempty" tf:"spec,omitempty"`

	// Status of the cluster
	Status map[string]*string `json:"status,omitempty" tf:"status,omitempty"`
}

type ClusterParameters struct {

	// +kubebuilder:validation:Optional
	AttachK8SCluster []AttachK8SClusterParameters `json:"attachK8SCluster,omitempty" tf:"attach_k8s_cluster,omitempty"`

	// Name of the management cluster
	// +kubebuilder:validation:Optional
	ManagementClusterName *string `json:"managementClusterName,omitempty" tf:"management_cluster_name,omitempty"`

	// Metadata for the resource
	// +kubebuilder:validation:Optional
	Meta []ClusterMetaParameters `json:"meta,omitempty" tf:"meta,omitempty"`

	// Name of this cluster
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Provisioner of the cluster
	// +kubebuilder:validation:Optional
	ProvisionerName *string `json:"provisionerName,omitempty" tf:"provisioner_name,omitempty"`

	// Wait timeout duration until cluster resource reaches READY state. Accepted timeout duration values like 5s, 45m, or 3h, higher than zero. Should be set to 0 in case of simple attach cluster where kubeconfig input is not provided.
	// +kubebuilder:validation:Optional
	ReadyWaitTimeout *string `json:"readyWaitTimeout,omitempty" tf:"ready_wait_timeout,omitempty"`

	// Spec for the cluster
	// +kubebuilder:validation:Optional
	Spec []ClusterSpecParameters `json:"spec,omitempty" tf:"spec,omitempty"`
}

type ClusterSpecObservation struct {

	// Name of the cluster group to which this cluster belongs
	ClusterGroup *string `json:"clusterGroup,omitempty" tf:"cluster_group,omitempty"`

	// Optional image registry name is the name of the image registry to be used for the cluster
	ImageRegistry *string `json:"imageRegistry,omitempty" tf:"image_registry,omitempty"`

	// Optional proxy name is the name of the Proxy Config to be used for the cluster
	Proxy *string `json:"proxy,omitempty" tf:"proxy,omitempty"`

	// The Tanzu Kubernetes Grid (TKGm) AWS cluster spec
	TkgAws []TkgAwsObservation `json:"tkgAws,omitempty" tf:"tkg_aws,omitempty"`

	// The Tanzu Kubernetes Grid Service (TKGs) cluster spec
	TkgServiceVsphere []TkgServiceVsphereObservation `json:"tkgServiceVsphere,omitempty" tf:"tkg_service_vsphere,omitempty"`

	// The Tanzu Kubernetes Grid (TKGm) vSphere cluster spec
	TkgVsphere []TkgVsphereObservation `json:"tkgVsphere,omitempty" tf:"tkg_vsphere,omitempty"`
}

type ClusterSpecParameters struct {

	// Name of the cluster group to which this cluster belongs
	// +kubebuilder:validation:Optional
	ClusterGroup *string `json:"clusterGroup,omitempty" tf:"cluster_group,omitempty"`

	// Optional image registry name is the name of the image registry to be used for the cluster
	// +kubebuilder:validation:Optional
	ImageRegistry *string `json:"imageRegistry,omitempty" tf:"image_registry,omitempty"`

	// Optional proxy name is the name of the Proxy Config to be used for the cluster
	// +kubebuilder:validation:Optional
	Proxy *string `json:"proxy,omitempty" tf:"proxy,omitempty"`

	// The Tanzu Kubernetes Grid (TKGm) AWS cluster spec
	// +kubebuilder:validation:Optional
	TkgAws []TkgAwsParameters `json:"tkgAws,omitempty" tf:"tkg_aws,omitempty"`

	// The Tanzu Kubernetes Grid Service (TKGs) cluster spec
	// +kubebuilder:validation:Optional
	TkgServiceVsphere []TkgServiceVsphereParameters `json:"tkgServiceVsphere,omitempty" tf:"tkg_service_vsphere,omitempty"`

	// The Tanzu Kubernetes Grid (TKGm) vSphere cluster spec
	// +kubebuilder:validation:Optional
	TkgVsphere []TkgVsphereParameters `json:"tkgVsphere,omitempty" tf:"tkg_vsphere,omitempty"`
}

type ControlPlaneObservation struct {

	// List of availability zones for the control plane nodes
	AvailabilityZones []*string `json:"availabilityZones,omitempty" tf:"availability_zones,omitempty"`

	// Flag which controls if the cluster needs to be highly available. HA cluster creates three controlplane machines, and non HA creates just one
	HighAvailability *bool `json:"highAvailability,omitempty" tf:"high_availability,omitempty"`

	// Control plane instance type
	InstanceType *string `json:"instanceType,omitempty" tf:"instance_type,omitempty"`
}

type ControlPlaneParameters struct {

	// List of availability zones for the control plane nodes
	// +kubebuilder:validation:Required
	AvailabilityZones []*string `json:"availabilityZones" tf:"availability_zones,omitempty"`

	// Flag which controls if the cluster needs to be highly available. HA cluster creates three controlplane machines, and non HA creates just one
	// +kubebuilder:validation:Optional
	HighAvailability *bool `json:"highAvailability,omitempty" tf:"high_availability,omitempty"`

	// Control plane instance type
	// +kubebuilder:validation:Required
	InstanceType *string `json:"instanceType" tf:"instance_type,omitempty"`
}

type DistributionObservation struct {

	// Arch of the OS used for the cluster
	OsArch *string `json:"osArch,omitempty" tf:"os_arch,omitempty"`

	// Name of the OS used for the cluster
	OsName *string `json:"osName,omitempty" tf:"os_name,omitempty"`

	// Version of the OS used for the cluster
	OsVersion *string `json:"osVersion,omitempty" tf:"os_version,omitempty"`

	// Specifies name of the account in which to create the cluster
	ProvisionerCredentialName *string `json:"provisionerCredentialName,omitempty" tf:"provisioner_credential_name,omitempty"`

	// Specifies region of the cluster
	Region *string `json:"region,omitempty" tf:"region,omitempty"`

	// Specifies version of the cluster
	Version *string `json:"version,omitempty" tf:"version,omitempty"`
}

type DistributionParameters struct {

	// Arch of the OS used for the cluster
	// +kubebuilder:validation:Optional
	OsArch *string `json:"osArch,omitempty" tf:"os_arch,omitempty"`

	// Name of the OS used for the cluster
	// +kubebuilder:validation:Optional
	OsName *string `json:"osName,omitempty" tf:"os_name,omitempty"`

	// Version of the OS used for the cluster
	// +kubebuilder:validation:Optional
	OsVersion *string `json:"osVersion,omitempty" tf:"os_version,omitempty"`

	// Specifies name of the account in which to create the cluster
	// +kubebuilder:validation:Optional
	ProvisionerCredentialName *string `json:"provisionerCredentialName,omitempty" tf:"provisioner_credential_name,omitempty"`

	// Specifies region of the cluster
	// +kubebuilder:validation:Required
	Region *string `json:"region" tf:"region,omitempty"`

	// Specifies version of the cluster
	// +kubebuilder:validation:Required
	Version *string `json:"version" tf:"version,omitempty"`
}

type InfoObservation struct {

	// Description of the nodepool
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Name of the nodepool
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type InfoParameters struct {

	// Description of the nodepool
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Name of the nodepool
	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`
}

type NetworkClusterObservation struct {

	// APIServerPort specifies the port address for the cluster that defaults to 6443.
	APIServerPort *float64 `json:"apiServerPort,omitempty" tf:"api_server_port,omitempty"`

	// Pod CIDR for Kubernetes pods defaults to 192.168.0.0/16
	Pods []PodsObservation `json:"pods,omitempty" tf:"pods,omitempty"`

	// Service CIDR for kubernetes services defaults to 10.96.0.0/12
	Services []ServicesObservation `json:"services,omitempty" tf:"services,omitempty"`
}

type NetworkClusterParameters struct {

	// APIServerPort specifies the port address for the cluster that defaults to 6443.
	// +kubebuilder:validation:Optional
	APIServerPort *float64 `json:"apiServerPort,omitempty" tf:"api_server_port,omitempty"`

	// Pod CIDR for Kubernetes pods defaults to 192.168.0.0/16
	// +kubebuilder:validation:Required
	Pods []PodsParameters `json:"pods" tf:"pods,omitempty"`

	// Service CIDR for kubernetes services defaults to 10.96.0.0/12
	// +kubebuilder:validation:Required
	Services []ServicesParameters `json:"services" tf:"services,omitempty"`
}

type NetworkObservation struct {

	// Cluster network specifies kubernetes network information for the cluster
	Cluster []NetworkClusterObservation `json:"cluster,omitempty" tf:"cluster,omitempty"`

	// Provider Network specifies provider specific network information for the cluster
	Provider []ProviderObservation `json:"provider,omitempty" tf:"provider,omitempty"`
}

type NetworkParameters struct {

	// Cluster network specifies kubernetes network information for the cluster
	// +kubebuilder:validation:Required
	Cluster []NetworkClusterParameters `json:"cluster" tf:"cluster,omitempty"`

	// Provider Network specifies provider specific network information for the cluster
	// +kubebuilder:validation:Required
	Provider []ProviderParameters `json:"provider" tf:"provider,omitempty"`
}

type NetworkPodsObservation struct {

	// CIDRBlocks specifies one or more ranges of IP addresses
	CidrBlocks []*string `json:"cidrBlocks,omitempty" tf:"cidr_blocks,omitempty"`
}

type NetworkPodsParameters struct {

	// CIDRBlocks specifies one or more ranges of IP addresses
	// +kubebuilder:validation:Required
	CidrBlocks []*string `json:"cidrBlocks" tf:"cidr_blocks,omitempty"`
}

type NetworkServicesObservation struct {

	// CIDRBlocks specifies one or more ranges of IP addresses
	CidrBlocks []*string `json:"cidrBlocks,omitempty" tf:"cidr_blocks,omitempty"`
}

type NetworkServicesParameters struct {

	// CIDRBlocks specifies one or more ranges of IP addresses
	// +kubebuilder:validation:Required
	CidrBlocks []*string `json:"cidrBlocks" tf:"cidr_blocks,omitempty"`
}

type NodePlacementObservation struct {

	// The Availability Zone where the AWS nodes are placed
	AwsAvailabilityZone *string `json:"awsAvailabilityZone,omitempty" tf:"aws_availability_zone,omitempty"`
}

type NodePlacementParameters struct {

	// The Availability Zone where the AWS nodes are placed
	// +kubebuilder:validation:Required
	AwsAvailabilityZone *string `json:"awsAvailabilityZone" tf:"aws_availability_zone,omitempty"`
}

type NodePoolsInfoObservation struct {

	// Description for the nodepool
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Name of the nodepool
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type NodePoolsInfoParameters struct {

	// Description for the nodepool
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Name of the nodepool
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type NodePoolsObservation struct {

	// Info is the meta information of nodepool for cluster
	Info []InfoObservation `json:"info,omitempty" tf:"info,omitempty"`

	// Spec for the cluster nodepool
	Spec []NodePoolsSpecObservation `json:"spec,omitempty" tf:"spec,omitempty"`
}

type NodePoolsParameters struct {

	// Info is the meta information of nodepool for cluster
	// +kubebuilder:validation:Required
	Info []InfoParameters `json:"info" tf:"info,omitempty"`

	// Spec for the cluster nodepool
	// +kubebuilder:validation:Optional
	Spec []NodePoolsSpecParameters `json:"spec,omitempty" tf:"spec,omitempty"`
}

type NodePoolsSpecObservation struct {

	// Nodepool config for tkg aws
	TkgAws []SpecTkgAwsObservation `json:"tkgAws,omitempty" tf:"tkg_aws,omitempty"`

	// Count is the number of nodes
	WorkerNodeCount *string `json:"workerNodeCount,omitempty" tf:"worker_node_count,omitempty"`
}

type NodePoolsSpecParameters struct {

	// Nodepool config for tkg aws
	// +kubebuilder:validation:Optional
	TkgAws []SpecTkgAwsParameters `json:"tkgAws,omitempty" tf:"tkg_aws,omitempty"`

	// Count is the number of nodes
	// +kubebuilder:validation:Optional
	WorkerNodeCount *string `json:"workerNodeCount,omitempty" tf:"worker_node_count,omitempty"`
}

type PodsObservation struct {

	// CIDRBlocks specifies one or more of IP address ranges
	CidrBlocks *string `json:"cidrBlocks,omitempty" tf:"cidr_blocks,omitempty"`
}

type PodsParameters struct {

	// CIDRBlocks specifies one or more of IP address ranges
	// +kubebuilder:validation:Required
	CidrBlocks *string `json:"cidrBlocks" tf:"cidr_blocks,omitempty"`
}

type ProviderObservation struct {

	// Optional list of subnets used to place the nodes in the cluster
	Subnets []SubnetsObservation `json:"subnets,omitempty" tf:"subnets,omitempty"`

	// AWS VPC configuration for the cluster
	VPC []VPCObservation `json:"vpc,omitempty" tf:"vpc,omitempty"`
}

type ProviderParameters struct {

	// Optional list of subnets used to place the nodes in the cluster
	// +kubebuilder:validation:Optional
	Subnets []SubnetsParameters `json:"subnets,omitempty" tf:"subnets,omitempty"`

	// AWS VPC configuration for the cluster
	// +kubebuilder:validation:Required
	VPC []VPCParameters `json:"vpc" tf:"vpc,omitempty"`
}

type SecurityObservation struct {

	// SSH key for provisioning and accessing the cluster VMs
	SSHKey *string `json:"sshKey,omitempty" tf:"ssh_key,omitempty"`
}

type SecurityParameters struct {

	// SSH key for provisioning and accessing the cluster VMs
	// +kubebuilder:validation:Required
	SSHKey *string `json:"sshKey" tf:"ssh_key,omitempty"`
}

type ServicesObservation struct {

	// CIDRBlocks specifies one or more of IP address ranges
	CidrBlocks *string `json:"cidrBlocks,omitempty" tf:"cidr_blocks,omitempty"`
}

type ServicesParameters struct {

	// CIDRBlocks specifies one or more of IP address ranges
	// +kubebuilder:validation:Required
	CidrBlocks *string `json:"cidrBlocks" tf:"cidr_blocks,omitempty"`
}

type SettingsNetworkObservation struct {

	// Pod CIDR for Kubernetes pods defaults to 192.168.0.0/16
	Pods []NetworkPodsObservation `json:"pods,omitempty" tf:"pods,omitempty"`

	// Service CIDR for kubernetes services defaults to 10.96.0.0/12
	Services []NetworkServicesObservation `json:"services,omitempty" tf:"services,omitempty"`
}

type SettingsNetworkParameters struct {

	// Pod CIDR for Kubernetes pods defaults to 192.168.0.0/16
	// +kubebuilder:validation:Required
	Pods []NetworkPodsParameters `json:"pods" tf:"pods,omitempty"`

	// Service CIDR for kubernetes services defaults to 10.96.0.0/12
	// +kubebuilder:validation:Required
	Services []NetworkServicesParameters `json:"services" tf:"services,omitempty"`
}

type SettingsNetworkPodsObservation struct {

	// CIDRBlocks specifies one or more ranges of IP addresses
	CidrBlocks []*string `json:"cidrBlocks,omitempty" tf:"cidr_blocks,omitempty"`
}

type SettingsNetworkPodsParameters struct {

	// CIDRBlocks specifies one or more ranges of IP addresses
	// +kubebuilder:validation:Required
	CidrBlocks []*string `json:"cidrBlocks" tf:"cidr_blocks,omitempty"`
}

type SettingsNetworkServicesObservation struct {

	// CIDRBlocks specifies one or more ranges of IP addresses
	CidrBlocks []*string `json:"cidrBlocks,omitempty" tf:"cidr_blocks,omitempty"`
}

type SettingsNetworkServicesParameters struct {

	// CIDRBlocks specifies one or more ranges of IP addresses
	// +kubebuilder:validation:Required
	CidrBlocks []*string `json:"cidrBlocks" tf:"cidr_blocks,omitempty"`
}

type SettingsObservation struct {

	// Network Settings specifies network-related settings for the cluster
	Network []NetworkObservation `json:"network,omitempty" tf:"network,omitempty"`

	// Security Settings specifies security-related settings for the cluster
	Security []SecurityObservation `json:"security,omitempty" tf:"security,omitempty"`
}

type SettingsParameters struct {

	// Network Settings specifies network-related settings for the cluster
	// +kubebuilder:validation:Required
	Network []NetworkParameters `json:"network" tf:"network,omitempty"`

	// Security Settings specifies security-related settings for the cluster
	// +kubebuilder:validation:Required
	Security []SecurityParameters `json:"security" tf:"security,omitempty"`
}

type SettingsSecurityObservation struct {

	// SSH key for provisioning and accessing the cluster VMs
	SSHKey *string `json:"sshKey,omitempty" tf:"ssh_key,omitempty"`
}

type SettingsSecurityParameters struct {

	// SSH key for provisioning and accessing the cluster VMs
	// +kubebuilder:validation:Required
	SSHKey *string `json:"sshKey" tf:"ssh_key,omitempty"`
}

type SpecTkgAwsObservation struct {

	// Availability zone for the nodepool that is to be used when you are creating a nodepool for cluster in TMC hosted AWS solution
	AvailabilityZone *string `json:"availabilityZone,omitempty" tf:"availability_zone,omitempty"`

	// Nodepool instance type whose potential values could be found using cluster:options api
	InstanceType *string `json:"instanceType,omitempty" tf:"instance_type,omitempty"`

	// List of Availability Zones to place the AWS nodes on. Please use this field to provision a nodepool for workload cluster on an attached TKG AWS management cluster
	NodePlacement []NodePlacementObservation `json:"nodePlacement,omitempty" tf:"node_placement,omitempty"`

	// Subnet ID of the private subnet in which you want the nodes to be created in
	NodepoolSubnetID *string `json:"nodepoolSubnetId,omitempty" tf:"nodepool_subnet_id,omitempty"`

	// Kubernetes version of the node pool
	Version *string `json:"version,omitempty" tf:"version,omitempty"`
}

type SpecTkgAwsParameters struct {

	// Availability zone for the nodepool that is to be used when you are creating a nodepool for cluster in TMC hosted AWS solution
	// +kubebuilder:validation:Optional
	AvailabilityZone *string `json:"availabilityZone,omitempty" tf:"availability_zone,omitempty"`

	// Nodepool instance type whose potential values could be found using cluster:options api
	// +kubebuilder:validation:Required
	InstanceType *string `json:"instanceType" tf:"instance_type,omitempty"`

	// List of Availability Zones to place the AWS nodes on. Please use this field to provision a nodepool for workload cluster on an attached TKG AWS management cluster
	// +kubebuilder:validation:Required
	NodePlacement []NodePlacementParameters `json:"nodePlacement" tf:"node_placement,omitempty"`

	// Kubernetes version of the node pool
	// +kubebuilder:validation:Required
	Version *string `json:"version" tf:"version,omitempty"`
}

type SpecTkgServiceVsphereObservation struct {

	// Control plane instance type
	Class *string `json:"class,omitempty" tf:"class,omitempty"`

	// Configure the failure domain of node pool. The potential values could be found using cluster:options api.
	FailureDomain *string `json:"failureDomain,omitempty" tf:"failure_domain,omitempty"`

	// Storage Class to be used for storage of the disks which store the root filesystems of the nodes
	StorageClass *string `json:"storageClass,omitempty" tf:"storage_class,omitempty"`

	// Configurable volumes for control plane nodes
	Volumes []TkgServiceVsphereVolumesObservation `json:"volumes,omitempty" tf:"volumes,omitempty"`
}

type SpecTkgServiceVsphereParameters struct {

	// Control plane instance type
	// +kubebuilder:validation:Required
	Class *string `json:"class" tf:"class,omitempty"`

	// Configure the failure domain of node pool. The potential values could be found using cluster:options api.
	// +kubebuilder:validation:Optional
	FailureDomain *string `json:"failureDomain,omitempty" tf:"failure_domain,omitempty"`

	// Storage Class to be used for storage of the disks which store the root filesystems of the nodes
	// +kubebuilder:validation:Required
	StorageClass *string `json:"storageClass" tf:"storage_class,omitempty"`

	// Configurable volumes for control plane nodes
	// +kubebuilder:validation:Optional
	Volumes []TkgServiceVsphereVolumesParameters `json:"volumes,omitempty" tf:"volumes,omitempty"`
}

type SpecTkgVsphereObservation struct {

	// VM specific configuration
	VMConfig []TkgVsphereVMConfigObservation `json:"vmConfig,omitempty" tf:"vm_config,omitempty"`
}

type SpecTkgVsphereParameters struct {

	// VM specific configuration
	// +kubebuilder:validation:Required
	VMConfig []TkgVsphereVMConfigParameters `json:"vmConfig" tf:"vm_config,omitempty"`
}

type StorageObservation struct {

	// Classes is a list of storage classes from the supervisor namespace to expose within a cluster. If omitted, all storage classes from the supervisor namespace will be exposed within the cluster.
	Classes []*string `json:"classes,omitempty" tf:"classes,omitempty"`

	// DefaultClass is the valid storage class name which is treated as the default storage class within a cluster. If omitted, no default storage class is set.
	DefaultClass *string `json:"defaultClass,omitempty" tf:"default_class,omitempty"`
}

type StorageParameters struct {

	// Classes is a list of storage classes from the supervisor namespace to expose within a cluster. If omitted, all storage classes from the supervisor namespace will be exposed within the cluster.
	// +kubebuilder:validation:Optional
	Classes []*string `json:"classes,omitempty" tf:"classes,omitempty"`

	// DefaultClass is the valid storage class name which is treated as the default storage class within a cluster. If omitted, no default storage class is set.
	// +kubebuilder:validation:Optional
	DefaultClass *string `json:"defaultClass,omitempty" tf:"default_class,omitempty"`
}

type SubnetsObservation struct {

	// AWS availability zone e.g. us-west-2a
	AvailabilityZone *string `json:"availabilityZone,omitempty" tf:"availability_zone,omitempty"`

	// CIDR for AWS subnet which must be in the range of AWS VPC CIDR block
	CidrBlockSubnet *string `json:"cidrBlockSubnet,omitempty" tf:"cidr_block_subnet,omitempty"`

	// Describes if it is public subnet or private subnet
	IsPublic *bool `json:"isPublic,omitempty" tf:"is_public,omitempty"`

	// This is the subnet ID of AWS. The rest of the fields are ignored if this field is specified
	SubnetID *string `json:"subnetId,omitempty" tf:"subnet_id,omitempty"`
}

type SubnetsParameters struct {

	// AWS availability zone e.g. us-west-2a
	// +kubebuilder:validation:Optional
	AvailabilityZone *string `json:"availabilityZone,omitempty" tf:"availability_zone,omitempty"`

	// CIDR for AWS subnet which must be in the range of AWS VPC CIDR block
	// +kubebuilder:validation:Optional
	CidrBlockSubnet *string `json:"cidrBlockSubnet,omitempty" tf:"cidr_block_subnet,omitempty"`

	// Describes if it is public subnet or private subnet
	// +kubebuilder:validation:Optional
	IsPublic *bool `json:"isPublic,omitempty" tf:"is_public,omitempty"`

	// This is the subnet ID of AWS. The rest of the fields are ignored if this field is specified
	// +kubebuilder:validation:Optional
	SubnetID *string `json:"subnetId,omitempty" tf:"subnet_id,omitempty"`
}

type TkgAwsObservation struct {

	// Advanced configuration for TKGm cluster
	AdvancedConfigs []AdvancedConfigsObservation `json:"advancedConfigs,omitempty" tf:"advanced_configs,omitempty"`

	// Kubernetes version distribution for the cluster
	Distribution []DistributionObservation `json:"distribution,omitempty" tf:"distribution,omitempty"`

	// AWS related settings for workload cluster
	Settings []SettingsObservation `json:"settings,omitempty" tf:"settings,omitempty"`

	// Topology configuration of the cluster
	Topology []TopologyObservation `json:"topology,omitempty" tf:"topology,omitempty"`
}

type TkgAwsParameters struct {

	// Advanced configuration for TKGm cluster
	// +kubebuilder:validation:Optional
	AdvancedConfigs []AdvancedConfigsParameters `json:"advancedConfigs,omitempty" tf:"advanced_configs,omitempty"`

	// Kubernetes version distribution for the cluster
	// +kubebuilder:validation:Required
	Distribution []DistributionParameters `json:"distribution" tf:"distribution,omitempty"`

	// AWS related settings for workload cluster
	// +kubebuilder:validation:Required
	Settings []SettingsParameters `json:"settings" tf:"settings,omitempty"`

	// Topology configuration of the cluster
	// +kubebuilder:validation:Required
	Topology []TopologyParameters `json:"topology" tf:"topology,omitempty"`
}

type TkgServiceVsphereDistributionObservation struct {

	// Arch of the OS used for the cluster
	OsArch *string `json:"osArch,omitempty" tf:"os_arch,omitempty"`

	// Name of the OS used for the cluster
	OsName *string `json:"osName,omitempty" tf:"os_name,omitempty"`

	// Version of the OS used for the cluster
	OsVersion *string `json:"osVersion,omitempty" tf:"os_version,omitempty"`

	// Version of the cluster
	Version *string `json:"version,omitempty" tf:"version,omitempty"`
}

type TkgServiceVsphereDistributionParameters struct {

	// Arch of the OS used for the cluster
	// +kubebuilder:validation:Optional
	OsArch *string `json:"osArch,omitempty" tf:"os_arch,omitempty"`

	// Name of the OS used for the cluster
	// +kubebuilder:validation:Optional
	OsName *string `json:"osName,omitempty" tf:"os_name,omitempty"`

	// Version of the OS used for the cluster
	// +kubebuilder:validation:Optional
	OsVersion *string `json:"osVersion,omitempty" tf:"os_version,omitempty"`

	// Version of the cluster
	// +kubebuilder:validation:Required
	Version *string `json:"version" tf:"version,omitempty"`
}

type TkgServiceVsphereObservation struct {

	// VSphere specific distribution
	Distribution []TkgServiceVsphereDistributionObservation `json:"distribution,omitempty" tf:"distribution,omitempty"`

	// VSphere related settings for workload cluster
	Settings []TkgServiceVsphereSettingsObservation `json:"settings,omitempty" tf:"settings,omitempty"`

	// Topology specific configuration
	Topology []TkgServiceVsphereTopologyObservation `json:"topology,omitempty" tf:"topology,omitempty"`
}

type TkgServiceVsphereParameters struct {

	// VSphere specific distribution
	// +kubebuilder:validation:Required
	Distribution []TkgServiceVsphereDistributionParameters `json:"distribution" tf:"distribution,omitempty"`

	// VSphere related settings for workload cluster
	// +kubebuilder:validation:Required
	Settings []TkgServiceVsphereSettingsParameters `json:"settings" tf:"settings,omitempty"`

	// Topology specific configuration
	// +kubebuilder:validation:Required
	Topology []TkgServiceVsphereTopologyParameters `json:"topology" tf:"topology,omitempty"`
}

type TkgServiceVsphereSettingsObservation struct {

	// Network Settings specifies network-related settings for the cluster
	Network []SettingsNetworkObservation `json:"network,omitempty" tf:"network,omitempty"`

	// StorageSettings specifies storage-related settings for the cluster
	Storage []StorageObservation `json:"storage,omitempty" tf:"storage,omitempty"`
}

type TkgServiceVsphereSettingsParameters struct {

	// Network Settings specifies network-related settings for the cluster
	// +kubebuilder:validation:Required
	Network []SettingsNetworkParameters `json:"network" tf:"network,omitempty"`

	// StorageSettings specifies storage-related settings for the cluster
	// +kubebuilder:validation:Optional
	Storage []StorageParameters `json:"storage,omitempty" tf:"storage,omitempty"`
}

type TkgServiceVsphereTopologyObservation struct {

	// Control plane specific configuration
	ControlPlane []TopologyControlPlaneObservation `json:"controlPlane,omitempty" tf:"control_plane,omitempty"`

	// Nodepool specific configuration
	NodePools []TopologyNodePoolsObservation `json:"nodePools,omitempty" tf:"node_pools,omitempty"`
}

type TkgServiceVsphereTopologyParameters struct {

	// Control plane specific configuration
	// +kubebuilder:validation:Required
	ControlPlane []TopologyControlPlaneParameters `json:"controlPlane" tf:"control_plane,omitempty"`

	// Nodepool specific configuration
	// +kubebuilder:validation:Optional
	NodePools []TopologyNodePoolsParameters `json:"nodePools,omitempty" tf:"node_pools,omitempty"`
}

type TkgServiceVsphereVolumesObservation struct {

	// Volume capacity is in gib
	Capacity *float64 `json:"capacity,omitempty" tf:"capacity,omitempty"`

	// It is the directory where the volume device is to be mounted
	MountPath *string `json:"mountPath,omitempty" tf:"mount_path,omitempty"`

	// It is the volume name
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// This is the storage class for PVC which in case omitted, default storage class will be used for the disks
	PvcStorageClass *string `json:"pvcStorageClass,omitempty" tf:"pvc_storage_class,omitempty"`
}

type TkgServiceVsphereVolumesParameters struct {

	// Volume capacity is in gib
	// +kubebuilder:validation:Optional
	Capacity *float64 `json:"capacity,omitempty" tf:"capacity,omitempty"`

	// It is the directory where the volume device is to be mounted
	// +kubebuilder:validation:Optional
	MountPath *string `json:"mountPath,omitempty" tf:"mount_path,omitempty"`

	// It is the volume name
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// This is the storage class for PVC which in case omitted, default storage class will be used for the disks
	// +kubebuilder:validation:Optional
	PvcStorageClass *string `json:"pvcStorageClass,omitempty" tf:"pvc_storage_class,omitempty"`
}

type TkgVsphereAdvancedConfigsObservation struct {

	// The key of the advanced configuration parameters
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// The value of the advanced configuration parameters
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type TkgVsphereAdvancedConfigsParameters struct {

	// The key of the advanced configuration parameters
	// +kubebuilder:validation:Required
	Key *string `json:"key" tf:"key,omitempty"`

	// The value of the advanced configuration parameters
	// +kubebuilder:validation:Required
	Value *string `json:"value" tf:"value,omitempty"`
}

type TkgVsphereDistributionObservation struct {

	// Arch of the OS used for the cluster
	OsArch *string `json:"osArch,omitempty" tf:"os_arch,omitempty"`

	// Name of the OS used for the cluster
	OsName *string `json:"osName,omitempty" tf:"os_name,omitempty"`

	// Version of the OS used for the cluster
	OsVersion *string `json:"osVersion,omitempty" tf:"os_version,omitempty"`

	// Version specifies the version of the Kubernetes cluster
	Version *string `json:"version,omitempty" tf:"version,omitempty"`

	// Workspace defines a workspace configuration for the vSphere cloud provider
	Workspace []WorkspaceObservation `json:"workspace,omitempty" tf:"workspace,omitempty"`
}

type TkgVsphereDistributionParameters struct {

	// Arch of the OS used for the cluster
	// +kubebuilder:validation:Optional
	OsArch *string `json:"osArch,omitempty" tf:"os_arch,omitempty"`

	// Name of the OS used for the cluster
	// +kubebuilder:validation:Optional
	OsName *string `json:"osName,omitempty" tf:"os_name,omitempty"`

	// Version of the OS used for the cluster
	// +kubebuilder:validation:Optional
	OsVersion *string `json:"osVersion,omitempty" tf:"os_version,omitempty"`

	// Version specifies the version of the Kubernetes cluster
	// +kubebuilder:validation:Required
	Version *string `json:"version" tf:"version,omitempty"`

	// Workspace defines a workspace configuration for the vSphere cloud provider
	// +kubebuilder:validation:Required
	Workspace []WorkspaceParameters `json:"workspace" tf:"workspace,omitempty"`
}

type TkgVsphereObservation struct {

	// Advanced configuration for TKGm cluster
	AdvancedConfigs []TkgVsphereAdvancedConfigsObservation `json:"advancedConfigs,omitempty" tf:"advanced_configs,omitempty"`

	// VSphere specific distribution
	Distribution []TkgVsphereDistributionObservation `json:"distribution,omitempty" tf:"distribution,omitempty"`

	// VSphere related settings for workload cluster
	Settings []TkgVsphereSettingsObservation `json:"settings,omitempty" tf:"settings,omitempty"`

	// Topology specific configuration
	Topology []TkgVsphereTopologyObservation `json:"topology,omitempty" tf:"topology,omitempty"`
}

type TkgVsphereParameters struct {

	// Advanced configuration for TKGm cluster
	// +kubebuilder:validation:Optional
	AdvancedConfigs []TkgVsphereAdvancedConfigsParameters `json:"advancedConfigs,omitempty" tf:"advanced_configs,omitempty"`

	// VSphere specific distribution
	// +kubebuilder:validation:Required
	Distribution []TkgVsphereDistributionParameters `json:"distribution" tf:"distribution,omitempty"`

	// VSphere related settings for workload cluster
	// +kubebuilder:validation:Required
	Settings []TkgVsphereSettingsParameters `json:"settings" tf:"settings,omitempty"`

	// Topology specific configuration
	// +kubebuilder:validation:Required
	Topology []TkgVsphereTopologyParameters `json:"topology" tf:"topology,omitempty"`
}

type TkgVsphereSettingsNetworkObservation struct {

	// APIServerPort specifies the port address for the cluster that defaults to 6443.
	APIServerPort *float64 `json:"apiServerPort,omitempty" tf:"api_server_port,omitempty"`

	// ControlPlaneEndpoint specifies the control plane virtual IP address. The value should be unique for every create request, else cluster creation shall fail. This field is not needed when AVI enabled while creating a legacy cluster on TKGm.
	ControlPlaneEndPoint *string `json:"controlPlaneEndPoint,omitempty" tf:"control_plane_end_point,omitempty"`

	// Pod CIDR for Kubernetes pods defaults to 192.168.0.0/16
	Pods []SettingsNetworkPodsObservation `json:"pods,omitempty" tf:"pods,omitempty"`

	// Service CIDR for kubernetes services defaults to 10.96.0.0/12
	Services []SettingsNetworkServicesObservation `json:"services,omitempty" tf:"services,omitempty"`
}

type TkgVsphereSettingsNetworkParameters struct {

	// APIServerPort specifies the port address for the cluster that defaults to 6443.
	// +kubebuilder:validation:Optional
	APIServerPort *float64 `json:"apiServerPort,omitempty" tf:"api_server_port,omitempty"`

	// ControlPlaneEndpoint specifies the control plane virtual IP address. The value should be unique for every create request, else cluster creation shall fail. This field is not needed when AVI enabled while creating a legacy cluster on TKGm.
	// +kubebuilder:validation:Optional
	ControlPlaneEndPoint *string `json:"controlPlaneEndPoint,omitempty" tf:"control_plane_end_point,omitempty"`

	// Pod CIDR for Kubernetes pods defaults to 192.168.0.0/16
	// +kubebuilder:validation:Required
	Pods []SettingsNetworkPodsParameters `json:"pods" tf:"pods,omitempty"`

	// Service CIDR for kubernetes services defaults to 10.96.0.0/12
	// +kubebuilder:validation:Required
	Services []SettingsNetworkServicesParameters `json:"services" tf:"services,omitempty"`
}

type TkgVsphereSettingsObservation struct {

	// Network Settings specifies network-related settings for the cluster
	Network []TkgVsphereSettingsNetworkObservation `json:"network,omitempty" tf:"network,omitempty"`

	// Security Settings specifies security-related settings for the cluster
	Security []SettingsSecurityObservation `json:"security,omitempty" tf:"security,omitempty"`
}

type TkgVsphereSettingsParameters struct {

	// Network Settings specifies network-related settings for the cluster
	// +kubebuilder:validation:Required
	Network []TkgVsphereSettingsNetworkParameters `json:"network" tf:"network,omitempty"`

	// Security Settings specifies security-related settings for the cluster
	// +kubebuilder:validation:Required
	Security []SettingsSecurityParameters `json:"security" tf:"security,omitempty"`
}

type TkgVsphereTopologyControlPlaneObservation struct {

	// High Availability or Non High Availability Cluster. HA cluster creates three controlplane machines, and non HA creates just one
	HighAvailability *bool `json:"highAvailability,omitempty" tf:"high_availability,omitempty"`

	// VM specific configuration
	VMConfig []VMConfigObservation `json:"vmConfig,omitempty" tf:"vm_config,omitempty"`
}

type TkgVsphereTopologyControlPlaneParameters struct {

	// High Availability or Non High Availability Cluster. HA cluster creates three controlplane machines, and non HA creates just one
	// +kubebuilder:validation:Optional
	HighAvailability *bool `json:"highAvailability,omitempty" tf:"high_availability,omitempty"`

	// VM specific configuration
	// +kubebuilder:validation:Required
	VMConfig []VMConfigParameters `json:"vmConfig" tf:"vm_config,omitempty"`
}

type TkgVsphereTopologyNodePoolsObservation struct {

	// Info is the meta information of nodepool for cluster
	Info []TopologyNodePoolsInfoObservation `json:"info,omitempty" tf:"info,omitempty"`

	// Spec for the cluster nodepool
	Spec []TkgVsphereTopologyNodePoolsSpecObservation `json:"spec,omitempty" tf:"spec,omitempty"`
}

type TkgVsphereTopologyNodePoolsParameters struct {

	// Info is the meta information of nodepool for cluster
	// +kubebuilder:validation:Required
	Info []TopologyNodePoolsInfoParameters `json:"info" tf:"info,omitempty"`

	// Spec for the cluster nodepool
	// +kubebuilder:validation:Optional
	Spec []TkgVsphereTopologyNodePoolsSpecParameters `json:"spec,omitempty" tf:"spec,omitempty"`
}

type TkgVsphereTopologyNodePoolsSpecObservation struct {

	// Nodepool config for tkgm vsphere
	TkgVsphere []SpecTkgVsphereObservation `json:"tkgVsphere,omitempty" tf:"tkg_vsphere,omitempty"`

	// Count is the number of nodes
	WorkerNodeCount *string `json:"workerNodeCount,omitempty" tf:"worker_node_count,omitempty"`
}

type TkgVsphereTopologyNodePoolsSpecParameters struct {

	// Nodepool config for tkgm vsphere
	// +kubebuilder:validation:Optional
	TkgVsphere []SpecTkgVsphereParameters `json:"tkgVsphere,omitempty" tf:"tkg_vsphere,omitempty"`

	// Count is the number of nodes
	// +kubebuilder:validation:Optional
	WorkerNodeCount *string `json:"workerNodeCount,omitempty" tf:"worker_node_count,omitempty"`
}

type TkgVsphereTopologyObservation struct {

	// VSphere specific control plane configuration for workload cluster object
	ControlPlane []TkgVsphereTopologyControlPlaneObservation `json:"controlPlane,omitempty" tf:"control_plane,omitempty"`

	// Nodepool specific configuration
	NodePools []TkgVsphereTopologyNodePoolsObservation `json:"nodePools,omitempty" tf:"node_pools,omitempty"`
}

type TkgVsphereTopologyParameters struct {

	// VSphere specific control plane configuration for workload cluster object
	// +kubebuilder:validation:Required
	ControlPlane []TkgVsphereTopologyControlPlaneParameters `json:"controlPlane" tf:"control_plane,omitempty"`

	// Nodepool specific configuration
	// +kubebuilder:validation:Optional
	NodePools []TkgVsphereTopologyNodePoolsParameters `json:"nodePools,omitempty" tf:"node_pools,omitempty"`
}

type TkgVsphereVMConfigObservation struct {

	// Number of CPUs per node
	CPU *string `json:"cpu,omitempty" tf:"cpu,omitempty"`

	// Root disk size in gigabytes for the VM
	DiskSize *string `json:"diskSize,omitempty" tf:"disk_size,omitempty"`

	// Memory associated with the node in megabytes
	Memory *string `json:"memory,omitempty" tf:"memory,omitempty"`
}

type TkgVsphereVMConfigParameters struct {

	// Number of CPUs per node
	// +kubebuilder:validation:Optional
	CPU *string `json:"cpu,omitempty" tf:"cpu,omitempty"`

	// Root disk size in gigabytes for the VM
	// +kubebuilder:validation:Optional
	DiskSize *string `json:"diskSize,omitempty" tf:"disk_size,omitempty"`

	// Memory associated with the node in megabytes
	// +kubebuilder:validation:Optional
	Memory *string `json:"memory,omitempty" tf:"memory,omitempty"`
}

type TopologyControlPlaneObservation struct {

	// Control plane instance type
	Class *string `json:"class,omitempty" tf:"class,omitempty"`

	// High Availability or Non High Availability Cluster. HA cluster creates three controlplane machines, and non HA creates just one
	HighAvailability *bool `json:"highAvailability,omitempty" tf:"high_availability,omitempty"`

	// Storage Class to be used for storage of the disks which store the root filesystems of the nodes
	StorageClass *string `json:"storageClass,omitempty" tf:"storage_class,omitempty"`

	// Configurable volumes for control plane nodes
	Volumes []VolumesObservation `json:"volumes,omitempty" tf:"volumes,omitempty"`
}

type TopologyControlPlaneParameters struct {

	// Control plane instance type
	// +kubebuilder:validation:Required
	Class *string `json:"class" tf:"class,omitempty"`

	// High Availability or Non High Availability Cluster. HA cluster creates three controlplane machines, and non HA creates just one
	// +kubebuilder:validation:Optional
	HighAvailability *bool `json:"highAvailability,omitempty" tf:"high_availability,omitempty"`

	// Storage Class to be used for storage of the disks which store the root filesystems of the nodes
	// +kubebuilder:validation:Required
	StorageClass *string `json:"storageClass" tf:"storage_class,omitempty"`

	// Configurable volumes for control plane nodes
	// +kubebuilder:validation:Optional
	Volumes []VolumesParameters `json:"volumes,omitempty" tf:"volumes,omitempty"`
}

type TopologyNodePoolsInfoObservation struct {

	// Description of the nodepool
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Name of the nodepool
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type TopologyNodePoolsInfoParameters struct {

	// Description of the nodepool
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Name of the nodepool
	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`
}

type TopologyNodePoolsObservation struct {

	// Info is the meta information of nodepool for cluster
	Info []NodePoolsInfoObservation `json:"info,omitempty" tf:"info,omitempty"`

	// Spec for the cluster nodepool
	Spec []TopologyNodePoolsSpecObservation `json:"spec,omitempty" tf:"spec,omitempty"`
}

type TopologyNodePoolsParameters struct {

	// Info is the meta information of nodepool for cluster
	// +kubebuilder:validation:Required
	Info []NodePoolsInfoParameters `json:"info" tf:"info,omitempty"`

	// Spec for the cluster nodepool
	// +kubebuilder:validation:Optional
	Spec []TopologyNodePoolsSpecParameters `json:"spec,omitempty" tf:"spec,omitempty"`
}

type TopologyNodePoolsSpecObservation struct {

	// Cloud labels
	CloudLabel map[string]*string `json:"cloudLabel,omitempty" tf:"cloud_label,omitempty"`

	// Node labels
	NodeLabel map[string]*string `json:"nodeLabel,omitempty" tf:"node_label,omitempty"`

	// Nodepool config for tkg service vsphere
	TkgServiceVsphere []SpecTkgServiceVsphereObservation `json:"tkgServiceVsphere,omitempty" tf:"tkg_service_vsphere,omitempty"`

	// Count is the number of nodes
	WorkerNodeCount *string `json:"workerNodeCount,omitempty" tf:"worker_node_count,omitempty"`
}

type TopologyNodePoolsSpecParameters struct {

	// Cloud labels
	// +kubebuilder:validation:Optional
	CloudLabel map[string]*string `json:"cloudLabel,omitempty" tf:"cloud_label,omitempty"`

	// Node labels
	// +kubebuilder:validation:Optional
	NodeLabel map[string]*string `json:"nodeLabel,omitempty" tf:"node_label,omitempty"`

	// Nodepool config for tkg service vsphere
	// +kubebuilder:validation:Optional
	TkgServiceVsphere []SpecTkgServiceVsphereParameters `json:"tkgServiceVsphere,omitempty" tf:"tkg_service_vsphere,omitempty"`

	// Count is the number of nodes
	// +kubebuilder:validation:Optional
	WorkerNodeCount *string `json:"workerNodeCount,omitempty" tf:"worker_node_count,omitempty"`
}

type TopologyObservation struct {

	// AWS specific control plane configuration for workload cluster object
	ControlPlane []ControlPlaneObservation `json:"controlPlane,omitempty" tf:"control_plane,omitempty"`

	// Nodepool specific configuration
	NodePools []NodePoolsObservation `json:"nodePools,omitempty" tf:"node_pools,omitempty"`
}

type TopologyParameters struct {

	// AWS specific control plane configuration for workload cluster object
	// +kubebuilder:validation:Required
	ControlPlane []ControlPlaneParameters `json:"controlPlane" tf:"control_plane,omitempty"`

	// Nodepool specific configuration
	// +kubebuilder:validation:Optional
	NodePools []NodePoolsParameters `json:"nodePools,omitempty" tf:"node_pools,omitempty"`
}

type VMConfigObservation struct {

	// Number of CPUs per node
	CPU *string `json:"cpu,omitempty" tf:"cpu,omitempty"`

	// Root disk size in gigabytes for the VM
	DiskSize *string `json:"diskSize,omitempty" tf:"disk_size,omitempty"`

	// Memory associated with the node in megabytes
	Memory *string `json:"memory,omitempty" tf:"memory,omitempty"`
}

type VMConfigParameters struct {

	// Number of CPUs per node
	// +kubebuilder:validation:Optional
	CPU *string `json:"cpu,omitempty" tf:"cpu,omitempty"`

	// Root disk size in gigabytes for the VM
	// +kubebuilder:validation:Optional
	DiskSize *string `json:"diskSize,omitempty" tf:"disk_size,omitempty"`

	// Memory associated with the node in megabytes
	// +kubebuilder:validation:Optional
	Memory *string `json:"memory,omitempty" tf:"memory,omitempty"`
}

type VPCObservation struct {

	// CIDR for AWS VPC. A valid example is 10.0.0.0/16
	CidrBlockVPC *string `json:"cidrBlockVpc,omitempty" tf:"cidr_block_vpc,omitempty"`

	// AWS VPC ID. The rest of the fields are ignored if this field is specified.
	VPCID *string `json:"vpcId,omitempty" tf:"vpc_id,omitempty"`
}

type VPCParameters struct {

	// CIDR for AWS VPC. A valid example is 10.0.0.0/16
	// +kubebuilder:validation:Optional
	CidrBlockVPC *string `json:"cidrBlockVpc,omitempty" tf:"cidr_block_vpc,omitempty"`

	// AWS VPC ID. The rest of the fields are ignored if this field is specified.
	// +kubebuilder:validation:Optional
	VPCID *string `json:"vpcId,omitempty" tf:"vpc_id,omitempty"`
}

type VolumesObservation struct {

	// Volume capacity is in gib
	Capacity *float64 `json:"capacity,omitempty" tf:"capacity,omitempty"`

	// It is the directory where the volume device is to be mounted
	MountPath *string `json:"mountPath,omitempty" tf:"mount_path,omitempty"`

	// It is the volume name
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// This is the storage class for PVC which in case omitted, default storage class will be used for the disks
	PvcStorageClass *string `json:"pvcStorageClass,omitempty" tf:"pvc_storage_class,omitempty"`
}

type VolumesParameters struct {

	// Volume capacity is in gib
	// +kubebuilder:validation:Optional
	Capacity *float64 `json:"capacity,omitempty" tf:"capacity,omitempty"`

	// It is the directory where the volume device is to be mounted
	// +kubebuilder:validation:Optional
	MountPath *string `json:"mountPath,omitempty" tf:"mount_path,omitempty"`

	// It is the volume name
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// This is the storage class for PVC which in case omitted, default storage class will be used for the disks
	// +kubebuilder:validation:Optional
	PvcStorageClass *string `json:"pvcStorageClass,omitempty" tf:"pvc_storage_class,omitempty"`
}

type WorkspaceObservation struct {
	Datacenter *string `json:"datacenter,omitempty" tf:"datacenter,omitempty"`

	Datastore *string `json:"datastore,omitempty" tf:"datastore,omitempty"`

	Folder *string `json:"folder,omitempty" tf:"folder,omitempty"`

	ResourcePool *string `json:"resourcePool,omitempty" tf:"resource_pool,omitempty"`

	WorkspaceNetwork *string `json:"workspaceNetwork,omitempty" tf:"workspace_network,omitempty"`
}

type WorkspaceParameters struct {

	// +kubebuilder:validation:Required
	Datacenter *string `json:"datacenter" tf:"datacenter,omitempty"`

	// +kubebuilder:validation:Required
	Datastore *string `json:"datastore" tf:"datastore,omitempty"`

	// +kubebuilder:validation:Required
	Folder *string `json:"folder" tf:"folder,omitempty"`

	// +kubebuilder:validation:Required
	ResourcePool *string `json:"resourcePool" tf:"resource_pool,omitempty"`

	// +kubebuilder:validation:Required
	WorkspaceNetwork *string `json:"workspaceNetwork" tf:"workspace_network,omitempty"`
}

// ClusterSpec defines the desired state of Cluster
type ClusterSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     ClusterParameters `json:"forProvider"`
}

// ClusterStatus defines the observed state of Cluster.
type ClusterStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        ClusterObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Cluster is the Schema for the Clusters API. <no value>
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,tmc}
type Cluster struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.name)",message="name is a required parameter"
	Spec   ClusterSpec   `json:"spec"`
	Status ClusterStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ClusterList contains a list of Clusters
type ClusterList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Cluster `json:"items"`
}

// Repository type metadata.
var (
	Cluster_Kind             = "Cluster"
	Cluster_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Cluster_Kind}.String()
	Cluster_KindAPIVersion   = Cluster_Kind + "." + CRDGroupVersion.String()
	Cluster_GroupVersionKind = CRDGroupVersion.WithKind(Cluster_Kind)
)

func init() {
	SchemeBuilder.Register(&Cluster{}, &ClusterList{})
}
