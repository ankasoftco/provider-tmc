/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AMIInfoObservation struct {

	// ID of the AMI to be used
	AMIID *string `json:"amiId,omitempty" tf:"ami_id,omitempty"`

	// Override bootstrap command for the custom AMI
	OverrideBootstrapCmd *string `json:"overrideBootstrapCmd,omitempty" tf:"override_bootstrap_cmd,omitempty"`
}

type AMIInfoParameters struct {

	// ID of the AMI to be used
	// +kubebuilder:validation:Optional
	AMIID *string `json:"amiId,omitempty" tf:"ami_id,omitempty"`

	// Override bootstrap command for the custom AMI
	// +kubebuilder:validation:Optional
	OverrideBootstrapCmd *string `json:"overrideBootstrapCmd,omitempty" tf:"override_bootstrap_cmd,omitempty"`
}

type AddonsConfigObservation struct {

	// VPC CNI addon config contains the configuration for the VPC CNI addon of the cluster
	VPCCniConfig []VPCCniConfigObservation `json:"vpcCniConfig,omitempty" tf:"vpc_cni_config,omitempty"`
}

type AddonsConfigParameters struct {

	// VPC CNI addon config contains the configuration for the VPC CNI addon of the cluster
	// +kubebuilder:validation:Optional
	VPCCniConfig []VPCCniConfigParameters `json:"vpcCniConfig,omitempty" tf:"vpc_cni_config,omitempty"`
}

type ConfigVPCObservation struct {

	// Enable Kubernetes API requests within your cluster's VPC (such as node to control plane communication) use the private VPC endpoint (see [Amazon EKS cluster endpoint access control](https://docs.aws.amazon.com/eks/latest/userguide/cluster-endpoint.html))
	EnablePrivateAccess *bool `json:"enablePrivateAccess,omitempty" tf:"enable_private_access,omitempty"`

	// Enable cluster API server access from the internet. You can, optionally, limit the CIDR blocks that can access the public endpoint using public_access_cidrs (see [Amazon EKS cluster endpoint access control](https://docs.aws.amazon.com/eks/latest/userguide/cluster-endpoint.html))
	EnablePublicAccess *bool `json:"enablePublicAccess,omitempty" tf:"enable_public_access,omitempty"`

	// Specify which addresses from the internet can communicate to the public endpoint, if public endpoint is enabled (see [Amazon EKS cluster endpoint access control](https://docs.aws.amazon.com/eks/latest/userguide/cluster-endpoint.html))
	PublicAccessCidrs []*string `json:"publicAccessCidrs,omitempty" tf:"public_access_cidrs,omitempty"`

	// Security groups for the cluster VMs
	SecurityGroups []*string `json:"securityGroups,omitempty" tf:"security_groups,omitempty"`

	// Subnet ids used by the cluster (see [Amazon EKS VPC and subnet requirements and considerations](https://docs.aws.amazon.com/eks/latest/userguide/network_reqs.html#network-requirements-subnets))
	SubnetIds []*string `json:"subnetIds,omitempty" tf:"subnet_ids,omitempty"`
}

type ConfigVPCParameters struct {

	// Enable Kubernetes API requests within your cluster's VPC (such as node to control plane communication) use the private VPC endpoint (see [Amazon EKS cluster endpoint access control](https://docs.aws.amazon.com/eks/latest/userguide/cluster-endpoint.html))
	// +kubebuilder:validation:Optional
	EnablePrivateAccess *bool `json:"enablePrivateAccess,omitempty" tf:"enable_private_access,omitempty"`

	// Enable cluster API server access from the internet. You can, optionally, limit the CIDR blocks that can access the public endpoint using public_access_cidrs (see [Amazon EKS cluster endpoint access control](https://docs.aws.amazon.com/eks/latest/userguide/cluster-endpoint.html))
	// +kubebuilder:validation:Optional
	EnablePublicAccess *bool `json:"enablePublicAccess,omitempty" tf:"enable_public_access,omitempty"`

	// Specify which addresses from the internet can communicate to the public endpoint, if public endpoint is enabled (see [Amazon EKS cluster endpoint access control](https://docs.aws.amazon.com/eks/latest/userguide/cluster-endpoint.html))
	// +kubebuilder:validation:Optional
	PublicAccessCidrs []*string `json:"publicAccessCidrs,omitempty" tf:"public_access_cidrs,omitempty"`

	// Security groups for the cluster VMs
	// +kubebuilder:validation:Optional
	SecurityGroups []*string `json:"securityGroups,omitempty" tf:"security_groups,omitempty"`

	// Subnet ids used by the cluster (see [Amazon EKS VPC and subnet requirements and considerations](https://docs.aws.amazon.com/eks/latest/userguide/network_reqs.html#network-requirements-subnets))
	// +kubebuilder:validation:Required
	SubnetIds []*string `json:"subnetIds" tf:"subnet_ids,omitempty"`
}

type EKSClusterMetaObservation struct {

	// Annotations for the resource
	Annotations map[string]*string `json:"annotations,omitempty" tf:"annotations,omitempty"`

	// Description of the resource
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Labels for the resource
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// Resource version of the resource
	ResourceVersion *string `json:"resourceVersion,omitempty" tf:"resource_version,omitempty"`

	// UID of the resource
	UID *string `json:"uid,omitempty" tf:"uid,omitempty"`
}

type EKSClusterMetaParameters struct {

	// Annotations for the resource
	// +kubebuilder:validation:Optional
	Annotations map[string]*string `json:"annotations,omitempty" tf:"annotations,omitempty"`

	// Description of the resource
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Labels for the resource
	// +kubebuilder:validation:Optional
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`
}

type EKSClusterObservation struct {

	// Name of the AWS Credential in Tanzu Mission Control
	CredentialName *string `json:"credentialName,omitempty" tf:"credential_name,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// Kubeconfig for connecting to newly created cluster base64 encoded. This will only be returned if you have elected to wait for kubeconfig.
	Kubeconfig *string `json:"kubeconfig,omitempty" tf:"kubeconfig,omitempty"`

	// Metadata for the resource
	Meta []EKSClusterMetaObservation `json:"meta,omitempty" tf:"meta,omitempty"`

	// Name of this cluster
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Wait timeout duration until cluster resource reaches READY state. Accepted timeout duration values like 5s, 45m, or 3h, higher than zero
	ReadyWaitTimeout *string `json:"readyWaitTimeout,omitempty" tf:"ready_wait_timeout,omitempty"`

	// AWS Region of this cluster
	Region *string `json:"region,omitempty" tf:"region,omitempty"`

	// Spec for the cluster
	Spec []EKSClusterSpecObservation `json:"spec,omitempty" tf:"spec,omitempty"`

	// Status of the cluster
	Status map[string]*string `json:"status,omitempty" tf:"status,omitempty"`

	// Wait until pinniped extension is ready to provide kubeconfig
	WaitForKubeconfig *bool `json:"waitForKubeconfig,omitempty" tf:"wait_for_kubeconfig,omitempty"`
}

type EKSClusterParameters struct {

	// Name of the AWS Credential in Tanzu Mission Control
	// +kubebuilder:validation:Optional
	CredentialName *string `json:"credentialName,omitempty" tf:"credential_name,omitempty"`

	// Metadata for the resource
	// +kubebuilder:validation:Optional
	Meta []EKSClusterMetaParameters `json:"meta,omitempty" tf:"meta,omitempty"`

	// Name of this cluster
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Wait timeout duration until cluster resource reaches READY state. Accepted timeout duration values like 5s, 45m, or 3h, higher than zero
	// +kubebuilder:validation:Optional
	ReadyWaitTimeout *string `json:"readyWaitTimeout,omitempty" tf:"ready_wait_timeout,omitempty"`

	// AWS Region of this cluster
	// +kubebuilder:validation:Optional
	Region *string `json:"region,omitempty" tf:"region,omitempty"`

	// Spec for the cluster
	// +kubebuilder:validation:Optional
	Spec []EKSClusterSpecParameters `json:"spec,omitempty" tf:"spec,omitempty"`

	// Wait until pinniped extension is ready to provide kubeconfig
	// +kubebuilder:validation:Optional
	WaitForKubeconfig *bool `json:"waitForKubeconfig,omitempty" tf:"wait_for_kubeconfig,omitempty"`
}

type EKSClusterSpecObservation struct {

	// Name of the cluster group to which this cluster belongs
	ClusterGroup *string `json:"clusterGroup,omitempty" tf:"cluster_group,omitempty"`

	// EKS config for the cluster control plane
	Config []SpecConfigObservation `json:"config,omitempty" tf:"config,omitempty"`

	// Nodepool definitions for the cluster
	Nodepool []SpecNodepoolObservation `json:"nodepool,omitempty" tf:"nodepool,omitempty"`

	// Optional proxy name is the name of the Proxy Config to be used for the cluster
	Proxy *string `json:"proxy,omitempty" tf:"proxy,omitempty"`
}

type EKSClusterSpecParameters struct {

	// Name of the cluster group to which this cluster belongs
	// +kubebuilder:validation:Optional
	ClusterGroup *string `json:"clusterGroup,omitempty" tf:"cluster_group,omitempty"`

	// EKS config for the cluster control plane
	// +kubebuilder:validation:Required
	Config []SpecConfigParameters `json:"config" tf:"config,omitempty"`

	// Nodepool definitions for the cluster
	// +kubebuilder:validation:Required
	Nodepool []SpecNodepoolParameters `json:"nodepool" tf:"nodepool,omitempty"`

	// Optional proxy name is the name of the Proxy Config to be used for the cluster
	// +kubebuilder:validation:Optional
	Proxy *string `json:"proxy,omitempty" tf:"proxy,omitempty"`
}

type EniConfigObservation struct {

	// Subnet id for the ENI
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// Security groups for the ENI
	SecurityGroups []*string `json:"securityGroups,omitempty" tf:"security_groups,omitempty"`
}

type EniConfigParameters struct {

	// Subnet id for the ENI
	// +kubebuilder:validation:Required
	ID *string `json:"id" tf:"id,omitempty"`

	// Security groups for the ENI
	// +kubebuilder:validation:Optional
	SecurityGroups []*string `json:"securityGroups,omitempty" tf:"security_groups,omitempty"`
}

type KubernetesNetworkConfigObservation struct {

	// Service CIDR for Kubernetes services
	ServiceCidr *string `json:"serviceCidr,omitempty" tf:"service_cidr,omitempty"`
}

type KubernetesNetworkConfigParameters struct {

	// Service CIDR for Kubernetes services
	// +kubebuilder:validation:Required
	ServiceCidr *string `json:"serviceCidr" tf:"service_cidr,omitempty"`
}

type LaunchTemplateObservation struct {

	// The ID of the launch template
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// The name of the launch template
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The version of the launch template to use
	Version *string `json:"version,omitempty" tf:"version,omitempty"`
}

type LaunchTemplateParameters struct {

	// The ID of the launch template
	// +kubebuilder:validation:Optional
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// The name of the launch template
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The version of the launch template to use
	// +kubebuilder:validation:Optional
	Version *string `json:"version,omitempty" tf:"version,omitempty"`
}

type LoggingObservation struct {

	// Enable API server logs
	APIServer *bool `json:"apiServer,omitempty" tf:"api_server,omitempty"`

	// Enable audit logs
	Audit *bool `json:"audit,omitempty" tf:"audit,omitempty"`

	// Enable authenticator logs
	Authenticator *bool `json:"authenticator,omitempty" tf:"authenticator,omitempty"`

	// Enable controller manager logs
	ControllerManager *bool `json:"controllerManager,omitempty" tf:"controller_manager,omitempty"`

	// Enable scheduler logs
	Scheduler *bool `json:"scheduler,omitempty" tf:"scheduler,omitempty"`
}

type LoggingParameters struct {

	// Enable API server logs
	// +kubebuilder:validation:Optional
	APIServer *bool `json:"apiServer,omitempty" tf:"api_server,omitempty"`

	// Enable audit logs
	// +kubebuilder:validation:Optional
	Audit *bool `json:"audit,omitempty" tf:"audit,omitempty"`

	// Enable authenticator logs
	// +kubebuilder:validation:Optional
	Authenticator *bool `json:"authenticator,omitempty" tf:"authenticator,omitempty"`

	// Enable controller manager logs
	// +kubebuilder:validation:Optional
	ControllerManager *bool `json:"controllerManager,omitempty" tf:"controller_manager,omitempty"`

	// Enable scheduler logs
	// +kubebuilder:validation:Optional
	Scheduler *bool `json:"scheduler,omitempty" tf:"scheduler,omitempty"`
}

type NodepoolInfoObservation struct {

	// Description for the nodepool
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Name of the nodepool, immutable
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type NodepoolInfoParameters struct {

	// Description for the nodepool
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Name of the nodepool, immutable
	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`
}

type RemoteAccessObservation struct {

	// SSH key allows you to connect to your instances and gather diagnostic information if there are issues.
	SSHKey *string `json:"sshKey,omitempty" tf:"ssh_key,omitempty"`

	// Security groups for the VMs
	SecurityGroups []*string `json:"securityGroups,omitempty" tf:"security_groups,omitempty"`
}

type RemoteAccessParameters struct {

	// SSH key allows you to connect to your instances and gather diagnostic information if there are issues.
	// +kubebuilder:validation:Optional
	SSHKey *string `json:"sshKey,omitempty" tf:"ssh_key,omitempty"`

	// Security groups for the VMs
	// +kubebuilder:validation:Optional
	SecurityGroups []*string `json:"securityGroups,omitempty" tf:"security_groups,omitempty"`
}

type ScalingConfigObservation struct {

	// Desired size of nodepool
	DesiredSize *float64 `json:"desiredSize,omitempty" tf:"desired_size,omitempty"`

	// Maximum size of nodepool
	MaxSize *float64 `json:"maxSize,omitempty" tf:"max_size,omitempty"`

	// Minimum size of nodepool
	MinSize *float64 `json:"minSize,omitempty" tf:"min_size,omitempty"`
}

type ScalingConfigParameters struct {

	// Desired size of nodepool
	// +kubebuilder:validation:Optional
	DesiredSize *float64 `json:"desiredSize,omitempty" tf:"desired_size,omitempty"`

	// Maximum size of nodepool
	// +kubebuilder:validation:Optional
	MaxSize *float64 `json:"maxSize,omitempty" tf:"max_size,omitempty"`

	// Minimum size of nodepool
	// +kubebuilder:validation:Optional
	MinSize *float64 `json:"minSize,omitempty" tf:"min_size,omitempty"`
}

type SpecConfigObservation struct {

	// Addons config contains the configuration for all the addons of the cluster, which support customization of addon configuration
	AddonsConfig []AddonsConfigObservation `json:"addonsConfig,omitempty" tf:"addons_config,omitempty"`

	// Kubernetes Network Config
	KubernetesNetworkConfig []KubernetesNetworkConfigObservation `json:"kubernetesNetworkConfig,omitempty" tf:"kubernetes_network_config,omitempty"`

	// Kubernetes version of the cluster
	KubernetesVersion *string `json:"kubernetesVersion,omitempty" tf:"kubernetes_version,omitempty"`

	// EKS logging configuration
	Logging []LoggingObservation `json:"logging,omitempty" tf:"logging,omitempty"`

	// ARN of the IAM role that provides permissions for the Kubernetes control plane to make calls to AWS API operations
	RoleArn *string `json:"roleArn,omitempty" tf:"role_arn,omitempty"`

	// The metadata to apply to the cluster to assist with categorization and organization
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// VPC config
	VPC []ConfigVPCObservation `json:"vpc,omitempty" tf:"vpc,omitempty"`
}

type SpecConfigParameters struct {

	// Addons config contains the configuration for all the addons of the cluster, which support customization of addon configuration
	// +kubebuilder:validation:Optional
	AddonsConfig []AddonsConfigParameters `json:"addonsConfig,omitempty" tf:"addons_config,omitempty"`

	// Kubernetes Network Config
	// +kubebuilder:validation:Optional
	KubernetesNetworkConfig []KubernetesNetworkConfigParameters `json:"kubernetesNetworkConfig,omitempty" tf:"kubernetes_network_config,omitempty"`

	// Kubernetes version of the cluster
	// +kubebuilder:validation:Required
	KubernetesVersion *string `json:"kubernetesVersion" tf:"kubernetes_version,omitempty"`

	// EKS logging configuration
	// +kubebuilder:validation:Optional
	Logging []LoggingParameters `json:"logging,omitempty" tf:"logging,omitempty"`

	// ARN of the IAM role that provides permissions for the Kubernetes control plane to make calls to AWS API operations
	// +kubebuilder:validation:Required
	RoleArn *string `json:"roleArn" tf:"role_arn,omitempty"`

	// The metadata to apply to the cluster to assist with categorization and organization
	// +kubebuilder:validation:Optional
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// VPC config
	// +kubebuilder:validation:Required
	VPC []ConfigVPCParameters `json:"vpc" tf:"vpc,omitempty"`
}

type SpecNodepoolObservation struct {

	// Info for the nodepool
	Info []NodepoolInfoObservation `json:"info,omitempty" tf:"info,omitempty"`

	// Spec for the cluster
	Spec []SpecNodepoolSpecObservation `json:"spec,omitempty" tf:"spec,omitempty"`
}

type SpecNodepoolParameters struct {

	// Info for the nodepool
	// +kubebuilder:validation:Required
	Info []NodepoolInfoParameters `json:"info" tf:"info,omitempty"`

	// Spec for the cluster
	// +kubebuilder:validation:Required
	Spec []SpecNodepoolSpecParameters `json:"spec" tf:"spec,omitempty"`
}

type SpecNodepoolSpecObservation struct {

	// AMI info for the nodepool if AMI type is specified as CUSTOM
	AMIInfo []AMIInfoObservation `json:"amiInfo,omitempty" tf:"ami_info,omitempty"`

	// AMI type, immutable
	AMIType *string `json:"amiType,omitempty" tf:"ami_type,omitempty"`

	// Capacity Type
	CapacityType *string `json:"capacityType,omitempty" tf:"capacity_type,omitempty"`

	// Nodepool instance types, immutable
	InstanceTypes []*string `json:"instanceTypes,omitempty" tf:"instance_types,omitempty"`

	// Launch template for the nodepool
	LaunchTemplate []LaunchTemplateObservation `json:"launchTemplate,omitempty" tf:"launch_template,omitempty"`

	// Kubernetes node labels
	NodeLabels map[string]*string `json:"nodeLabels,omitempty" tf:"node_labels,omitempty"`

	// AMI release version
	ReleaseVersion *string `json:"releaseVersion,omitempty" tf:"release_version,omitempty"`

	// Remote access to worker nodes, immutable
	RemoteAccess []RemoteAccessObservation `json:"remoteAccess,omitempty" tf:"remote_access,omitempty"`

	// ARN of the IAM role that provides permissions for the Kubernetes nodepool to make calls to AWS API operations, immutable
	RoleArn *string `json:"roleArn,omitempty" tf:"role_arn,omitempty"`

	// Root disk size in GiB, immutable
	RootDiskSize *float64 `json:"rootDiskSize,omitempty" tf:"root_disk_size,omitempty"`

	// Nodepool scaling config
	ScalingConfig []ScalingConfigObservation `json:"scalingConfig,omitempty" tf:"scaling_config,omitempty"`

	// Subnets required for the nodepool
	SubnetIds []*string `json:"subnetIds,omitempty" tf:"subnet_ids,omitempty"`

	// EKS specific tags
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// If specified, the node's taints
	Taints []SpecTaintsObservation `json:"taints,omitempty" tf:"taints,omitempty"`

	// Update config for the nodepool
	UpdateConfig []UpdateConfigObservation `json:"updateConfig,omitempty" tf:"update_config,omitempty"`
}

type SpecNodepoolSpecParameters struct {

	// AMI info for the nodepool if AMI type is specified as CUSTOM
	// +kubebuilder:validation:Optional
	AMIInfo []AMIInfoParameters `json:"amiInfo,omitempty" tf:"ami_info,omitempty"`

	// AMI type, immutable
	// +kubebuilder:validation:Optional
	AMIType *string `json:"amiType,omitempty" tf:"ami_type,omitempty"`

	// Capacity Type
	// +kubebuilder:validation:Optional
	CapacityType *string `json:"capacityType,omitempty" tf:"capacity_type,omitempty"`

	// Nodepool instance types, immutable
	// +kubebuilder:validation:Optional
	InstanceTypes []*string `json:"instanceTypes,omitempty" tf:"instance_types,omitempty"`

	// Launch template for the nodepool
	// +kubebuilder:validation:Optional
	LaunchTemplate []LaunchTemplateParameters `json:"launchTemplate,omitempty" tf:"launch_template,omitempty"`

	// Kubernetes node labels
	// +kubebuilder:validation:Optional
	NodeLabels map[string]*string `json:"nodeLabels,omitempty" tf:"node_labels,omitempty"`

	// AMI release version
	// +kubebuilder:validation:Optional
	ReleaseVersion *string `json:"releaseVersion,omitempty" tf:"release_version,omitempty"`

	// Remote access to worker nodes, immutable
	// +kubebuilder:validation:Optional
	RemoteAccess []RemoteAccessParameters `json:"remoteAccess,omitempty" tf:"remote_access,omitempty"`

	// ARN of the IAM role that provides permissions for the Kubernetes nodepool to make calls to AWS API operations, immutable
	// +kubebuilder:validation:Required
	RoleArn *string `json:"roleArn" tf:"role_arn,omitempty"`

	// Root disk size in GiB, immutable
	// +kubebuilder:validation:Optional
	RootDiskSize *float64 `json:"rootDiskSize,omitempty" tf:"root_disk_size,omitempty"`

	// Nodepool scaling config
	// +kubebuilder:validation:Optional
	ScalingConfig []ScalingConfigParameters `json:"scalingConfig,omitempty" tf:"scaling_config,omitempty"`

	// Subnets required for the nodepool
	// +kubebuilder:validation:Required
	SubnetIds []*string `json:"subnetIds" tf:"subnet_ids,omitempty"`

	// EKS specific tags
	// +kubebuilder:validation:Optional
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// If specified, the node's taints
	// +kubebuilder:validation:Optional
	Taints []SpecTaintsParameters `json:"taints,omitempty" tf:"taints,omitempty"`

	// Update config for the nodepool
	// +kubebuilder:validation:Optional
	UpdateConfig []UpdateConfigParameters `json:"updateConfig,omitempty" tf:"update_config,omitempty"`
}

type SpecTaintsObservation struct {

	// Current effect state of the node pool
	Effect *string `json:"effect,omitempty" tf:"effect,omitempty"`

	// The taint key to be applied to a node
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// The taint value corresponding to the taint key
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type SpecTaintsParameters struct {

	// Current effect state of the node pool
	// +kubebuilder:validation:Optional
	Effect *string `json:"effect,omitempty" tf:"effect,omitempty"`

	// The taint key to be applied to a node
	// +kubebuilder:validation:Optional
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// The taint value corresponding to the taint key
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type UpdateConfigObservation struct {

	// Maximum number of nodes unavailable at once during a version update
	MaxUnavailableNodes *string `json:"maxUnavailableNodes,omitempty" tf:"max_unavailable_nodes,omitempty"`

	// Maximum percentage of nodes unavailable during a version update
	MaxUnavailablePercentage *string `json:"maxUnavailablePercentage,omitempty" tf:"max_unavailable_percentage,omitempty"`
}

type UpdateConfigParameters struct {

	// Maximum number of nodes unavailable at once during a version update
	// +kubebuilder:validation:Optional
	MaxUnavailableNodes *string `json:"maxUnavailableNodes,omitempty" tf:"max_unavailable_nodes,omitempty"`

	// Maximum percentage of nodes unavailable during a version update
	// +kubebuilder:validation:Optional
	MaxUnavailablePercentage *string `json:"maxUnavailablePercentage,omitempty" tf:"max_unavailable_percentage,omitempty"`
}

type VPCCniConfigObservation struct {

	// ENI config for the VPC CNI addon
	EniConfig []EniConfigObservation `json:"eniConfig,omitempty" tf:"eni_config,omitempty"`
}

type VPCCniConfigParameters struct {

	// ENI config for the VPC CNI addon
	// +kubebuilder:validation:Optional
	EniConfig []EniConfigParameters `json:"eniConfig,omitempty" tf:"eni_config,omitempty"`
}

// EKSClusterSpec defines the desired state of EKSCluster
type EKSClusterSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     EKSClusterParameters `json:"forProvider"`
}

// EKSClusterStatus defines the observed state of EKSCluster.
type EKSClusterStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        EKSClusterObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// EKSCluster is the Schema for the EKSClusters API. <no value>
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,tmc}
type EKSCluster struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.credentialName)",message="credentialName is a required parameter"
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.name)",message="name is a required parameter"
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.region)",message="region is a required parameter"
	Spec   EKSClusterSpec   `json:"spec"`
	Status EKSClusterStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// EKSClusterList contains a list of EKSClusters
type EKSClusterList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []EKSCluster `json:"items"`
}

// Repository type metadata.
var (
	EKSCluster_Kind             = "EKSCluster"
	EKSCluster_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: EKSCluster_Kind}.String()
	EKSCluster_KindAPIVersion   = EKSCluster_Kind + "." + CRDGroupVersion.String()
	EKSCluster_GroupVersionKind = CRDGroupVersion.WithKind(EKSCluster_Kind)
)

func init() {
	SchemeBuilder.Register(&EKSCluster{}, &EKSClusterList{})
}
