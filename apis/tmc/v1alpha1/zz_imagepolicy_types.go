/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AllowedNameTagObservation struct {

	// Audit (dry-run). Violations will be logged but not denied.
	Audit *bool `json:"audit,omitempty" tf:"audit,omitempty"`

	// It specifies a list of rules that defines allowed image patterns.
	Rules []RulesObservation `json:"rules,omitempty" tf:"rules,omitempty"`
}

type AllowedNameTagParameters struct {

	// Audit (dry-run). Violations will be logged but not denied.
	// +kubebuilder:validation:Optional
	Audit *bool `json:"audit,omitempty" tf:"audit,omitempty"`

	// It specifies a list of rules that defines allowed image patterns.
	// +kubebuilder:validation:Required
	Rules []RulesParameters `json:"rules" tf:"rules,omitempty"`
}

type BlockLatestTagObservation struct {

	// Audit (dry-run). Violations will be logged but not denied.
	Audit *bool `json:"audit,omitempty" tf:"audit,omitempty"`
}

type BlockLatestTagParameters struct {

	// Audit (dry-run). Violations will be logged but not denied.
	// +kubebuilder:validation:Optional
	Audit *bool `json:"audit,omitempty" tf:"audit,omitempty"`
}

type CustomRulesObservation struct {

	// Allowed image hostnames, wildcards are supported(for example: *.mycompany.com). Empty field is equivalent to *.
	Hostname *string `json:"hostname,omitempty" tf:"hostname,omitempty"`

	// Allowed image names, wildcards are supported(for example: fooservice/*). Empty field is equivalent to *.
	Imagename *string `json:"imagename,omitempty" tf:"imagename,omitempty"`

	// Allowed port(if presented) of the image hostname, must associate with valid hostname. Wildcards are supported.
	Port *string `json:"port,omitempty" tf:"port,omitempty"`

	// The flag used to enforce digest to appear in container images.
	Requiredigest *bool `json:"requiredigest,omitempty" tf:"requiredigest,omitempty"`

	// Allowed image tag, wildcards are supported (for example: v1.*). No validation is performed on tag if the field is empty.
	Tag []RulesTagObservation `json:"tag,omitempty" tf:"tag,omitempty"`
}

type CustomRulesParameters struct {

	// Allowed image hostnames, wildcards are supported(for example: *.mycompany.com). Empty field is equivalent to *.
	// +kubebuilder:validation:Optional
	Hostname *string `json:"hostname,omitempty" tf:"hostname,omitempty"`

	// Allowed image names, wildcards are supported(for example: fooservice/*). Empty field is equivalent to *.
	// +kubebuilder:validation:Optional
	Imagename *string `json:"imagename,omitempty" tf:"imagename,omitempty"`

	// Allowed port(if presented) of the image hostname, must associate with valid hostname. Wildcards are supported.
	// +kubebuilder:validation:Optional
	Port *string `json:"port,omitempty" tf:"port,omitempty"`

	// The flag used to enforce digest to appear in container images.
	// +kubebuilder:validation:Optional
	Requiredigest *bool `json:"requiredigest,omitempty" tf:"requiredigest,omitempty"`

	// Allowed image tag, wildcards are supported (for example: v1.*). No validation is performed on tag if the field is empty.
	// +kubebuilder:validation:Optional
	Tag []RulesTagParameters `json:"tag,omitempty" tf:"tag,omitempty"`
}

type ImagePolicyMetaObservation struct {

	// Annotations for the resource
	Annotations map[string]*string `json:"annotations,omitempty" tf:"annotations,omitempty"`

	// Description of the resource
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Labels for the resource
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// Resource version of the resource
	ResourceVersion *string `json:"resourceVersion,omitempty" tf:"resource_version,omitempty"`

	// UID of the resource
	UID *string `json:"uid,omitempty" tf:"uid,omitempty"`
}

type ImagePolicyMetaParameters struct {

	// Annotations for the resource
	// +kubebuilder:validation:Optional
	Annotations map[string]*string `json:"annotations,omitempty" tf:"annotations,omitempty"`

	// Description of the resource
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Labels for the resource
	// +kubebuilder:validation:Optional
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`
}

type ImagePolicyObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// Metadata for the resource
	Meta []ImagePolicyMetaObservation `json:"meta,omitempty" tf:"meta,omitempty"`

	// Name of the image policy
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Scope for the custom, security, image, network, namespace quota and mutation policy, having one of the valid scopes for custom, security, mutation, and namespace quota policy: cluster, cluster_group or organization and valid scopes for image and network policy: workspace or organization.
	Scope []ImagePolicyScopeObservation `json:"scope,omitempty" tf:"scope,omitempty"`

	// Spec for the image policy
	Spec []ImagePolicySpecObservation `json:"spec,omitempty" tf:"spec,omitempty"`
}

type ImagePolicyParameters struct {

	// Metadata for the resource
	// +kubebuilder:validation:Optional
	Meta []ImagePolicyMetaParameters `json:"meta,omitempty" tf:"meta,omitempty"`

	// Name of the image policy
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Scope for the custom, security, image, network, namespace quota and mutation policy, having one of the valid scopes for custom, security, mutation, and namespace quota policy: cluster, cluster_group or organization and valid scopes for image and network policy: workspace or organization.
	// +kubebuilder:validation:Optional
	Scope []ImagePolicyScopeParameters `json:"scope,omitempty" tf:"scope,omitempty"`

	// Spec for the image policy
	// +kubebuilder:validation:Optional
	Spec []ImagePolicySpecParameters `json:"spec,omitempty" tf:"spec,omitempty"`
}

type ImagePolicyScopeClusterGroupObservation struct {

	// Name of this cluster group
	ClusterGroup *string `json:"clusterGroup,omitempty" tf:"cluster_group,omitempty"`
}

type ImagePolicyScopeClusterGroupParameters struct {

	// Name of this cluster group
	// +kubebuilder:validation:Required
	ClusterGroup *string `json:"clusterGroup" tf:"cluster_group,omitempty"`
}

type ImagePolicyScopeClusterObservation struct {

	// Name of the management cluster
	ManagementClusterName *string `json:"managementClusterName,omitempty" tf:"management_cluster_name,omitempty"`

	// Name of this cluster
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Provisioner of the cluster
	ProvisionerName *string `json:"provisionerName,omitempty" tf:"provisioner_name,omitempty"`
}

type ImagePolicyScopeClusterParameters struct {

	// Name of the management cluster
	// +kubebuilder:validation:Optional
	ManagementClusterName *string `json:"managementClusterName,omitempty" tf:"management_cluster_name,omitempty"`

	// Name of this cluster
	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// Provisioner of the cluster
	// +kubebuilder:validation:Optional
	ProvisionerName *string `json:"provisionerName,omitempty" tf:"provisioner_name,omitempty"`
}

type ImagePolicyScopeObservation struct {

	// The schema for cluster policy full name
	Cluster []ImagePolicyScopeClusterObservation `json:"cluster,omitempty" tf:"cluster,omitempty"`

	// The schema for cluster group policy full name
	ClusterGroup []ImagePolicyScopeClusterGroupObservation `json:"clusterGroup,omitempty" tf:"cluster_group,omitempty"`

	// The schema for organization policy full name
	Organization []ImagePolicyScopeOrganizationObservation `json:"organization,omitempty" tf:"organization,omitempty"`

	// The schema for workspace policy full name
	Workspace []ImagePolicyScopeWorkspaceObservation `json:"workspace,omitempty" tf:"workspace,omitempty"`
}

type ImagePolicyScopeOrganizationObservation struct {

	// ID of this organization
	Organization *string `json:"organization,omitempty" tf:"organization,omitempty"`
}

type ImagePolicyScopeOrganizationParameters struct {

	// ID of this organization
	// +kubebuilder:validation:Required
	Organization *string `json:"organization" tf:"organization,omitempty"`
}

type ImagePolicyScopeParameters struct {

	// The schema for cluster policy full name
	// +kubebuilder:validation:Optional
	Cluster []ImagePolicyScopeClusterParameters `json:"cluster,omitempty" tf:"cluster,omitempty"`

	// The schema for cluster group policy full name
	// +kubebuilder:validation:Optional
	ClusterGroup []ImagePolicyScopeClusterGroupParameters `json:"clusterGroup,omitempty" tf:"cluster_group,omitempty"`

	// The schema for organization policy full name
	// +kubebuilder:validation:Optional
	Organization []ImagePolicyScopeOrganizationParameters `json:"organization,omitempty" tf:"organization,omitempty"`

	// The schema for workspace policy full name
	// +kubebuilder:validation:Optional
	Workspace []ImagePolicyScopeWorkspaceParameters `json:"workspace,omitempty" tf:"workspace,omitempty"`
}

type ImagePolicyScopeWorkspaceObservation struct {

	// Name of this workspace
	Workspace *string `json:"workspace,omitempty" tf:"workspace,omitempty"`
}

type ImagePolicyScopeWorkspaceParameters struct {

	// Name of this workspace
	// +kubebuilder:validation:Required
	Workspace *string `json:"workspace" tf:"workspace,omitempty"`
}

type ImagePolicySpecObservation struct {

	// Input for the image policy, having one of the valid recipes: allowed-name-tag, custom, block-latest-tag or require-digest.
	Input []SpecInputObservation `json:"input,omitempty" tf:"input,omitempty"`

	// Label based Namespace Selector for the policy
	NamespaceSelector []SpecNamespaceSelectorObservation `json:"namespaceSelector,omitempty" tf:"namespace_selector,omitempty"`
}

type ImagePolicySpecParameters struct {

	// Input for the image policy, having one of the valid recipes: allowed-name-tag, custom, block-latest-tag or require-digest.
	// +kubebuilder:validation:Required
	Input []SpecInputParameters `json:"input" tf:"input,omitempty"`

	// Label based Namespace Selector for the policy
	// +kubebuilder:validation:Optional
	NamespaceSelector []SpecNamespaceSelectorParameters `json:"namespaceSelector,omitempty" tf:"namespace_selector,omitempty"`
}

type InputCustomObservation struct {

	// Audit (dry-run). Violations will be logged but not denied.
	Audit *bool `json:"audit,omitempty" tf:"audit,omitempty"`

	// It specifies a list of rules that defines allowed image patterns.
	Rules []CustomRulesObservation `json:"rules,omitempty" tf:"rules,omitempty"`
}

type InputCustomParameters struct {

	// Audit (dry-run). Violations will be logged but not denied.
	// +kubebuilder:validation:Optional
	Audit *bool `json:"audit,omitempty" tf:"audit,omitempty"`

	// It specifies a list of rules that defines allowed image patterns.
	// +kubebuilder:validation:Required
	Rules []CustomRulesParameters `json:"rules" tf:"rules,omitempty"`
}

type NamespaceSelectorMatchExpressionsObservation struct {

	// Key is the label key that the selector applies to
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// Operator represents a key's relationship to a set of values
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// Values is an array of string values
	Values []*string `json:"values,omitempty" tf:"values,omitempty"`
}

type NamespaceSelectorMatchExpressionsParameters struct {

	// Key is the label key that the selector applies to
	// +kubebuilder:validation:Optional
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// Operator represents a key's relationship to a set of values
	// +kubebuilder:validation:Optional
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// Values is an array of string values
	// +kubebuilder:validation:Required
	Values []*string `json:"values" tf:"values,omitempty"`
}

type RequireDigestObservation struct {

	// Audit (dry-run). Violations will be logged but not denied.
	Audit *bool `json:"audit,omitempty" tf:"audit,omitempty"`
}

type RequireDigestParameters struct {

	// Audit (dry-run). Violations will be logged but not denied.
	// +kubebuilder:validation:Optional
	Audit *bool `json:"audit,omitempty" tf:"audit,omitempty"`
}

type RulesObservation struct {

	// Allowed image names, wildcards are supported(for example: fooservice/*). Empty field is equivalent to *.
	Imagename *string `json:"imagename,omitempty" tf:"imagename,omitempty"`

	// Allowed image tag, wildcards are supported (for example: v1.*). No validation is performed on tag if the field is empty.
	Tag []TagObservation `json:"tag,omitempty" tf:"tag,omitempty"`
}

type RulesParameters struct {

	// Allowed image names, wildcards are supported(for example: fooservice/*). Empty field is equivalent to *.
	// +kubebuilder:validation:Optional
	Imagename *string `json:"imagename,omitempty" tf:"imagename,omitempty"`

	// Allowed image tag, wildcards are supported (for example: v1.*). No validation is performed on tag if the field is empty.
	// +kubebuilder:validation:Optional
	Tag []TagParameters `json:"tag,omitempty" tf:"tag,omitempty"`
}

type RulesTagObservation struct {

	// The negate flag used to exclude certain tag patterns.
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// The value (support wildcard) is used to validate against the tag of the image.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type RulesTagParameters struct {

	// The negate flag used to exclude certain tag patterns.
	// +kubebuilder:validation:Optional
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// The value (support wildcard) is used to validate against the tag of the image.
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type SpecInputObservation struct {

	// The input schema for image policy allowed-name-tag recipe version v1
	AllowedNameTag []AllowedNameTagObservation `json:"allowedNameTag,omitempty" tf:"allowed_name_tag,omitempty"`

	// The input schema for image policy block-latest-tag recipe version v1
	BlockLatestTag []BlockLatestTagObservation `json:"blockLatestTag,omitempty" tf:"block_latest_tag,omitempty"`

	// The input schema for image policy custom recipe version v1
	Custom []InputCustomObservation `json:"custom,omitempty" tf:"custom,omitempty"`

	// The input schema for image policy require-digest recipe version v1
	RequireDigest []RequireDigestObservation `json:"requireDigest,omitempty" tf:"require_digest,omitempty"`
}

type SpecInputParameters struct {

	// The input schema for image policy allowed-name-tag recipe version v1
	// +kubebuilder:validation:Optional
	AllowedNameTag []AllowedNameTagParameters `json:"allowedNameTag,omitempty" tf:"allowed_name_tag,omitempty"`

	// The input schema for image policy block-latest-tag recipe version v1
	// +kubebuilder:validation:Optional
	BlockLatestTag []BlockLatestTagParameters `json:"blockLatestTag,omitempty" tf:"block_latest_tag,omitempty"`

	// The input schema for image policy custom recipe version v1
	// +kubebuilder:validation:Optional
	Custom []InputCustomParameters `json:"custom,omitempty" tf:"custom,omitempty"`

	// The input schema for image policy require-digest recipe version v1
	// +kubebuilder:validation:Optional
	RequireDigest []RequireDigestParameters `json:"requireDigest,omitempty" tf:"require_digest,omitempty"`
}

type SpecNamespaceSelectorObservation struct {

	// Match expressions is a list of label selector requirements, the requirements are ANDed
	MatchExpressions []NamespaceSelectorMatchExpressionsObservation `json:"matchExpressions,omitempty" tf:"match_expressions,omitempty"`
}

type SpecNamespaceSelectorParameters struct {

	// Match expressions is a list of label selector requirements, the requirements are ANDed
	// +kubebuilder:validation:Required
	MatchExpressions []NamespaceSelectorMatchExpressionsParameters `json:"matchExpressions" tf:"match_expressions,omitempty"`
}

type TagObservation struct {

	// The negate flag used to exclude certain tag patterns.
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// The value (support wildcard) is used to validate against the tag of the image.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type TagParameters struct {

	// The negate flag used to exclude certain tag patterns.
	// +kubebuilder:validation:Optional
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// The value (support wildcard) is used to validate against the tag of the image.
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

// ImagePolicySpec defines the desired state of ImagePolicy
type ImagePolicySpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     ImagePolicyParameters `json:"forProvider"`
}

// ImagePolicyStatus defines the observed state of ImagePolicy.
type ImagePolicyStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        ImagePolicyObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// ImagePolicy is the Schema for the ImagePolicys API. <no value>
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,tmc}
type ImagePolicy struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.name)",message="name is a required parameter"
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.scope)",message="scope is a required parameter"
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.spec)",message="spec is a required parameter"
	Spec   ImagePolicySpec   `json:"spec"`
	Status ImagePolicyStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ImagePolicyList contains a list of ImagePolicys
type ImagePolicyList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ImagePolicy `json:"items"`
}

// Repository type metadata.
var (
	ImagePolicy_Kind             = "ImagePolicy"
	ImagePolicy_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: ImagePolicy_Kind}.String()
	ImagePolicy_KindAPIVersion   = ImagePolicy_Kind + "." + CRDGroupVersion.String()
	ImagePolicy_GroupVersionKind = CRDGroupVersion.WithKind(ImagePolicy_Kind)
)

func init() {
	SchemeBuilder.Register(&ImagePolicy{}, &ImagePolicyList{})
}
