/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type Git_RepositoryMetaObservation struct {

	// Annotations for the resource
	Annotations map[string]*string `json:"annotations,omitempty" tf:"annotations,omitempty"`

	// Description of the resource
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Labels for the resource
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// Resource version of the resource
	ResourceVersion *string `json:"resourceVersion,omitempty" tf:"resource_version,omitempty"`

	// UID of the resource
	UID *string `json:"uid,omitempty" tf:"uid,omitempty"`
}

type Git_RepositoryMetaParameters struct {

	// Annotations for the resource
	// +kubebuilder:validation:Optional
	Annotations map[string]*string `json:"annotations,omitempty" tf:"annotations,omitempty"`

	// Description of the resource
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Labels for the resource
	// +kubebuilder:validation:Optional
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`
}

type Git_RepositoryObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// Metadata for the resource
	Meta []Git_RepositoryMetaObservation `json:"meta,omitempty" tf:"meta,omitempty"`

	// Name of the Repository.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Name of Namespace.
	NamespaceName *string `json:"namespaceName,omitempty" tf:"namespace_name,omitempty"`

	// Scope for the git repository, having one of the valid scopes: cluster, cluster_group.
	Scope []Git_RepositoryScopeObservation `json:"scope,omitempty" tf:"scope,omitempty"`

	// Spec for the Repository.
	Spec []Git_RepositorySpecObservation `json:"spec,omitempty" tf:"spec,omitempty"`

	// Status for the Repository.
	Status map[string]*string `json:"status,omitempty" tf:"status,omitempty"`
}

type Git_RepositoryParameters struct {

	// Metadata for the resource
	// +kubebuilder:validation:Optional
	Meta []Git_RepositoryMetaParameters `json:"meta,omitempty" tf:"meta,omitempty"`

	// Name of the Repository.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Name of Namespace.
	// +kubebuilder:validation:Optional
	NamespaceName *string `json:"namespaceName,omitempty" tf:"namespace_name,omitempty"`

	// Scope for the git repository, having one of the valid scopes: cluster, cluster_group.
	// +kubebuilder:validation:Optional
	Scope []Git_RepositoryScopeParameters `json:"scope,omitempty" tf:"scope,omitempty"`

	// Spec for the Repository.
	// +kubebuilder:validation:Optional
	Spec []Git_RepositorySpecParameters `json:"spec,omitempty" tf:"spec,omitempty"`
}

type Git_RepositoryScopeClusterObservation struct {

	// Name of the management cluster
	ManagementClusterName *string `json:"managementClusterName,omitempty" tf:"management_cluster_name,omitempty"`

	// Name of this cluster
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Provisioner of the cluster
	ProvisionerName *string `json:"provisionerName,omitempty" tf:"provisioner_name,omitempty"`
}

type Git_RepositoryScopeClusterParameters struct {

	// Name of the management cluster
	// +kubebuilder:validation:Optional
	ManagementClusterName *string `json:"managementClusterName,omitempty" tf:"management_cluster_name,omitempty"`

	// Name of this cluster
	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// Provisioner of the cluster
	// +kubebuilder:validation:Optional
	ProvisionerName *string `json:"provisionerName,omitempty" tf:"provisioner_name,omitempty"`
}

type Git_RepositoryScopeObservation struct {

	// The schema for cluster full name
	Cluster []Git_RepositoryScopeClusterObservation `json:"cluster,omitempty" tf:"cluster,omitempty"`

	// The schema for cluster group full name
	ClusterGroup []ScopeClusterGroupObservation `json:"clusterGroup,omitempty" tf:"cluster_group,omitempty"`
}

type Git_RepositoryScopeParameters struct {

	// The schema for cluster full name
	// +kubebuilder:validation:Optional
	Cluster []Git_RepositoryScopeClusterParameters `json:"cluster,omitempty" tf:"cluster,omitempty"`

	// The schema for cluster group full name
	// +kubebuilder:validation:Optional
	ClusterGroup []ScopeClusterGroupParameters `json:"clusterGroup,omitempty" tf:"cluster_group,omitempty"`
}

type Git_RepositorySpecObservation struct {

	// GitImplementation specifies which client library implementation to use. go-git is the default git implementation.
	GitImplementation *string `json:"gitImplementation,omitempty" tf:"git_implementation,omitempty"`

	// Interval at which to check gitrepository for updates. This is the interval at which Tanzu Mission Control will attempt to reconcile changes in the repository to the cluster. A sync interval of 0 would result in no future syncs. If no value is entered, a default interval of 5 minutes will be applied as `5m`.
	Interval *string `json:"interval,omitempty" tf:"interval,omitempty"`

	// Reference specifies git reference to resolve.
	Ref []RefObservation `json:"ref,omitempty" tf:"ref,omitempty"`

	// Reference to the secret. Repository credential.
	SecretRef *string `json:"secretRef,omitempty" tf:"secret_ref,omitempty"`

	// URL of the git repository. Repository URL should begin with http, https, or ssh
	URL *string `json:"url,omitempty" tf:"url,omitempty"`
}

type Git_RepositorySpecParameters struct {

	// GitImplementation specifies which client library implementation to use. go-git is the default git implementation.
	// +kubebuilder:validation:Optional
	GitImplementation *string `json:"gitImplementation,omitempty" tf:"git_implementation,omitempty"`

	// Interval at which to check gitrepository for updates. This is the interval at which Tanzu Mission Control will attempt to reconcile changes in the repository to the cluster. A sync interval of 0 would result in no future syncs. If no value is entered, a default interval of 5 minutes will be applied as `5m`.
	// +kubebuilder:validation:Optional
	Interval *string `json:"interval,omitempty" tf:"interval,omitempty"`

	// Reference specifies git reference to resolve.
	// +kubebuilder:validation:Optional
	Ref []RefParameters `json:"ref,omitempty" tf:"ref,omitempty"`

	// Reference to the secret. Repository credential.
	// +kubebuilder:validation:Optional
	SecretRef *string `json:"secretRef,omitempty" tf:"secret_ref,omitempty"`

	// URL of the git repository. Repository URL should begin with http, https, or ssh
	// +kubebuilder:validation:Required
	URL *string `json:"url" tf:"url,omitempty"`
}

type RefObservation struct {

	// Branch from git to checkout. When branch is given, then that branch from the git repository will be checked out. If the given branch doesn’t exist in the git repository, then adding the git repository will fail. If no branch is given, the `master` branch will be used.
	Branch *string `json:"branch,omitempty" tf:"branch,omitempty"`

	// Commit SHA to checkout. Takes precedence over all other reference fields. When git_implementation is `GO_GIT`, this can be combined with branch to shallow clone branch in which the commit is expected to exist.
	Commit *string `json:"commit,omitempty" tf:"commit,omitempty"`

	// SemVer expression to checkout from git tags. Takes precedence over tag. When semver is given, then the latest tag matching that semver will be checked out from the git repository. If no tag in the git repository matches semver, then adding the git repository will fail. If semver is given, tag and branch will be ignored if they are populated.
	Semver *string `json:"semver,omitempty" tf:"semver,omitempty"`

	// Tag from git to checkout. Takes precedence over branch. When a tag is given, that tag from the git repository will be checked out. If the given tag doesn’t exist in the git repository, then adding the git repository will fail. If both tag and branch are given, tag overrides branch and the branch value will be ignored.
	Tag *string `json:"tag,omitempty" tf:"tag,omitempty"`
}

type RefParameters struct {

	// Branch from git to checkout. When branch is given, then that branch from the git repository will be checked out. If the given branch doesn’t exist in the git repository, then adding the git repository will fail. If no branch is given, the `master` branch will be used.
	// +kubebuilder:validation:Optional
	Branch *string `json:"branch,omitempty" tf:"branch,omitempty"`

	// Commit SHA to checkout. Takes precedence over all other reference fields. When git_implementation is `GO_GIT`, this can be combined with branch to shallow clone branch in which the commit is expected to exist.
	// +kubebuilder:validation:Optional
	Commit *string `json:"commit,omitempty" tf:"commit,omitempty"`

	// SemVer expression to checkout from git tags. Takes precedence over tag. When semver is given, then the latest tag matching that semver will be checked out from the git repository. If no tag in the git repository matches semver, then adding the git repository will fail. If semver is given, tag and branch will be ignored if they are populated.
	// +kubebuilder:validation:Optional
	Semver *string `json:"semver,omitempty" tf:"semver,omitempty"`

	// Tag from git to checkout. Takes precedence over branch. When a tag is given, that tag from the git repository will be checked out. If the given tag doesn’t exist in the git repository, then adding the git repository will fail. If both tag and branch are given, tag overrides branch and the branch value will be ignored.
	// +kubebuilder:validation:Optional
	Tag *string `json:"tag,omitempty" tf:"tag,omitempty"`
}

type ScopeClusterGroupObservation struct {

	// Name of the cluster group
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type ScopeClusterGroupParameters struct {

	// Name of the cluster group
	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`
}

// Git_RepositorySpec defines the desired state of Git_Repository
type Git_RepositorySpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     Git_RepositoryParameters `json:"forProvider"`
}

// Git_RepositoryStatus defines the observed state of Git_Repository.
type Git_RepositoryStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        Git_RepositoryObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Git_Repository is the Schema for the Git_Repositorys API. <no value>
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,tmc}
type Git_Repository struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.name)",message="name is a required parameter"
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.namespaceName)",message="namespaceName is a required parameter"
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.scope)",message="scope is a required parameter"
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.spec)",message="spec is a required parameter"
	Spec   Git_RepositorySpec   `json:"spec"`
	Status Git_RepositoryStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// Git_RepositoryList contains a list of Git_Repositorys
type Git_RepositoryList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Git_Repository `json:"items"`
}

// Repository type metadata.
var (
	Git_Repository_Kind             = "Git_Repository"
	Git_Repository_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Git_Repository_Kind}.String()
	Git_Repository_KindAPIVersion   = Git_Repository_Kind + "." + CRDGroupVersion.String()
	Git_Repository_GroupVersionKind = CRDGroupVersion.WithKind(Git_Repository_Kind)
)

func init() {
	SchemeBuilder.Register(&Git_Repository{}, &Git_RepositoryList{})
}
